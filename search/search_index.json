{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GatorGrade","title":"Home"},{"location":"#gatorgrade","text":"","title":"GatorGrade"},{"location":"reference/Summary/","text":"generate generate input checks command_line_generator in_file_path parse_config set_up_shell main output check_result output","title":"Summary"},{"location":"reference/main/","text":"Use Typer to run gatorgrade to run the checks and generate the yml file. gatorgrade ( ctx , filename = typer . Option ( FILE , '--config' , '-c' , help = 'Name of the yml file.' )) Run the GatorGrader checks in the gatorgrade.yml file. Source code in gatorgrade/main.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @app . callback ( invoke_without_command = True ) def gatorgrade ( ctx : typer . Context , filename : Path = typer . Option ( FILE , \"--config\" , \"-c\" , help = \"Name of the yml file.\" ), ): \"\"\"Run the GatorGrader checks in the gatorgrade.yml file.\"\"\" # if ctx.subcommand is None then this means # that, by default, gatorgrade should run in checking mode if ctx . invoked_subcommand is None : # parse the provided configuration file checks = parse_config ( filename ) # there are valid checks and thus the # tool should run them with run_checks if len ( checks ) > 0 : checks_status = run_checks ( checks ) # no checks were created and this means # that, most likely, the file was not # valid and thus the tool cannot run checks else : checks_status = False console . print () console . print ( f \"The file { filename } either does not exist or is not valid.\" ) console . print ( \"Exiting now!\" ) console . print () # at least one of the checks did not pass or # the provided file was not valid and thus # the tool should return a non-zero exit # code to designate some type of failure if checks_status is not True : sys . exit ( FAILURE ) generate ( root = typer . Argument ( Path ( '.' ), help = 'Root directory of the assignment' , exists = True , dir_okay = True , writable = True ), paths = typer . Option ([ '*' ], help = 'Paths to recurse through and generate checks for' , exists = False )) Generate a gatorgrade.yml file. Source code in gatorgrade/main.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @app . command () def generate ( root : Path = typer . Argument ( Path ( \".\" ), help = \"Root directory of the assignment\" , exists = True , dir_okay = True , writable = True , ), paths : List [ Path ] = typer . Option ( [ \"*\" ], help = \"Paths to recurse through and generate checks for\" , exists = False , ), ): \"\"\"Generate a gatorgrade.yml file.\"\"\" targets = [] for path in paths : targets . extend ( glob . iglob ( path . as_posix (), recursive = True )) generate_config ( targets , root . as_posix ())","title":"main"},{"location":"reference/main/#gatorgrade.main.gatorgrade","text":"Run the GatorGrader checks in the gatorgrade.yml file. Source code in gatorgrade/main.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @app . callback ( invoke_without_command = True ) def gatorgrade ( ctx : typer . Context , filename : Path = typer . Option ( FILE , \"--config\" , \"-c\" , help = \"Name of the yml file.\" ), ): \"\"\"Run the GatorGrader checks in the gatorgrade.yml file.\"\"\" # if ctx.subcommand is None then this means # that, by default, gatorgrade should run in checking mode if ctx . invoked_subcommand is None : # parse the provided configuration file checks = parse_config ( filename ) # there are valid checks and thus the # tool should run them with run_checks if len ( checks ) > 0 : checks_status = run_checks ( checks ) # no checks were created and this means # that, most likely, the file was not # valid and thus the tool cannot run checks else : checks_status = False console . print () console . print ( f \"The file { filename } either does not exist or is not valid.\" ) console . print ( \"Exiting now!\" ) console . print () # at least one of the checks did not pass or # the provided file was not valid and thus # the tool should return a non-zero exit # code to designate some type of failure if checks_status is not True : sys . exit ( FAILURE )","title":"gatorgrade()"},{"location":"reference/main/#gatorgrade.main.generate","text":"Generate a gatorgrade.yml file. Source code in gatorgrade/main.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @app . command () def generate ( root : Path = typer . Argument ( Path ( \".\" ), help = \"Root directory of the assignment\" , exists = True , dir_okay = True , writable = True , ), paths : List [ Path ] = typer . Option ( [ \"*\" ], help = \"Paths to recurse through and generate checks for\" , exists = False , ), ): \"\"\"Generate a gatorgrade.yml file.\"\"\" targets = [] for path in paths : targets . extend ( glob . iglob ( path . as_posix (), recursive = True )) generate_config ( targets , root . as_posix ())","title":"generate()"},{"location":"reference/generate/generate/","text":"Generate a YAML file with default messages and specific paths. create_targeted_paths_list ( target_path_list , relative_run_path = '.' ) Generate a list of targeted paths by walking the paths. Source code in gatorgrade/generate/generate.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def create_targeted_paths_list ( target_path_list : List [ str ], relative_run_path : str = \".\" ) -> List [ str ]: \"\"\"Generate a list of targeted paths by walking the paths.\"\"\" targeted_paths = [] corrected_paths = input_correct ( target_path_list , relative_run_path ) # Go through the root repo, the sub dictionaries and files # The os.walk will only scan the paths # So the empty folders containing nothing won't be gone through for dirpath , _ , filenames in os . walk ( relative_run_path ): # Split path string into multiple layers of directories path_dir_list = dirpath . split ( os . path . sep ) # Ignore folder starting with double underscore if any ( path . startswith ( \"__\" ) for path in path_dir_list ): continue # Ignore hidden folders and first layer. the root repo is always dot # Keep double dot. It means going back to the parent folder if any ( path . startswith ( \".\" ) and not path . startswith ( \"..\" ) for path in path_dir_list [ 1 :] ): continue for filename in filenames : # Ignore special files if filename . startswith ( \"__\" ) or filename . startswith ( \".\" ): continue # Combine the path with file name to get a complete path complete_actual_path = os . path . join ( dirpath , filename ) + os . path . sep for target in corrected_paths : if target in complete_actual_path : polished_paths = complete_actual_path . replace ( f \" { relative_run_path }{ os . path . sep } \" , \"\" ) targeted_paths . append ( polished_paths ) # If any of the user inputted file does not exist in any directory, # throw an exception indicating failure if not targeted_paths : typer . secho ( \"FAILURE: None of the user-provided file paths are\" \" found in the provided directory and the 'gatorgrade.yml' is NOT generated\" , fg = typer . colors . RED , err = True , ) raise typer . Exit ( 1 ) # If some of the files are found and some are not found, # output a warning message saying which files were not found targeted_paths_string = \" \" . join ( targeted_paths ) for key in target_path_list : if key not in targeted_paths_string : typer . secho ( f \"WARNING \\u26A0 : ' { key } ' file path is not FOUND!\" f \" \\n All file paths except ' { key } ' are successfully\" \" generated in the 'gatorgrade.yml' file\" , fg = typer . colors . YELLOW , ) return targeted_paths # If all the files exist in the root directory, print out a success message if targeted_paths : typer . secho ( \"SUCCESS \\U0001F525 : All the file paths were\" \" successfully generated in the 'gatorgrade.yml' file!\" , fg = typer . colors . GREEN , ) return targeted_paths generate_config ( target_path_list , search_root = '.' ) Generate config by creating targeted paths in a list of strings, then create a YAML file. Source code in gatorgrade/generate/generate.py 136 137 138 139 def generate_config ( target_path_list : List [ str ], search_root : str = \".\" ): \"\"\"Generate config by creating targeted paths in a list of strings, then create a YAML file.\"\"\" targeted_paths = create_targeted_paths_list ( target_path_list , search_root ) write_yaml_of_paths_list ( targeted_paths , search_root ) input_correct ( initial_path_list , run_path ) Correct user-written paths. Source code in gatorgrade/generate/generate.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def input_correct ( initial_path_list : List [ str ], run_path : str ) -> Dict : \"\"\"Correct user-written paths.\"\"\" # Recognize the paths users provide are the concise versions. # Unify the ending format to avoid different users' different input corrected_path = [] # Run_path unify if run_path . endswith ( os . path . sep ) is False : run_path += os . path . sep for path in initial_path_list : # Combine the running path with the target path # To make sure the target path starts from the running directory path = run_path + path # Treat the last unit of the path as a concise name unit if path . endswith ( os . path . sep ) is False : path += os . path . sep corrected_path . append ( path ) # Convert list to dictionary for faster iteration return dict . fromkeys ( corrected_path , \"\" ) write_yaml_of_paths_list ( path_names , search_root ) Write YAML file to create gatorgrade file and set default messages. Source code in gatorgrade/generate/generate.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def write_yaml_of_paths_list ( path_names : List [ str ], search_root : str ): # expected input: A path list \"\"\"Write YAML file to create gatorgrade file and set default messages.\"\"\" files_list = [] # Create an empty list to store dictionaries for file_path in path_names : # Iterate through items in path_names if file_path . endswith ( os . path . sep ): file_path = file_path [ 0 : - 1 ] # Convert file separators to '/' file_path_fixed = file_path . replace ( os . path . sep , \"/\" ) # Make file_path easier to read by removing unnecessary characters file_path_dict = { # Dictionary to store the file paths file_path_fixed : [ # List which stores strings which will be in gatorgrade.yml file { \"description\" : f \"Complete all TODOs in { file_path_fixed } \" , \"check\" : \"MatchFileFragment\" , \"options\" : { \"fragment\" : \"TODO\" , \"count\" : 0 , \"exact\" : True }, } ] } # Append files_list with the values stored inside file_path_dict files_list . append ( file_path_dict ) with open ( f \" { search_root }{ os . path . sep } gatorgrade.yml\" , \"w\" , encoding = \"utf-8\" ) as file : # Write a new YAML file named gatorgrade yaml . dump ( files_list , file , sort_keys = False )","title":"generate"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.create_targeted_paths_list","text":"Generate a list of targeted paths by walking the paths. Source code in gatorgrade/generate/generate.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def create_targeted_paths_list ( target_path_list : List [ str ], relative_run_path : str = \".\" ) -> List [ str ]: \"\"\"Generate a list of targeted paths by walking the paths.\"\"\" targeted_paths = [] corrected_paths = input_correct ( target_path_list , relative_run_path ) # Go through the root repo, the sub dictionaries and files # The os.walk will only scan the paths # So the empty folders containing nothing won't be gone through for dirpath , _ , filenames in os . walk ( relative_run_path ): # Split path string into multiple layers of directories path_dir_list = dirpath . split ( os . path . sep ) # Ignore folder starting with double underscore if any ( path . startswith ( \"__\" ) for path in path_dir_list ): continue # Ignore hidden folders and first layer. the root repo is always dot # Keep double dot. It means going back to the parent folder if any ( path . startswith ( \".\" ) and not path . startswith ( \"..\" ) for path in path_dir_list [ 1 :] ): continue for filename in filenames : # Ignore special files if filename . startswith ( \"__\" ) or filename . startswith ( \".\" ): continue # Combine the path with file name to get a complete path complete_actual_path = os . path . join ( dirpath , filename ) + os . path . sep for target in corrected_paths : if target in complete_actual_path : polished_paths = complete_actual_path . replace ( f \" { relative_run_path }{ os . path . sep } \" , \"\" ) targeted_paths . append ( polished_paths ) # If any of the user inputted file does not exist in any directory, # throw an exception indicating failure if not targeted_paths : typer . secho ( \"FAILURE: None of the user-provided file paths are\" \" found in the provided directory and the 'gatorgrade.yml' is NOT generated\" , fg = typer . colors . RED , err = True , ) raise typer . Exit ( 1 ) # If some of the files are found and some are not found, # output a warning message saying which files were not found targeted_paths_string = \" \" . join ( targeted_paths ) for key in target_path_list : if key not in targeted_paths_string : typer . secho ( f \"WARNING \\u26A0 : ' { key } ' file path is not FOUND!\" f \" \\n All file paths except ' { key } ' are successfully\" \" generated in the 'gatorgrade.yml' file\" , fg = typer . colors . YELLOW , ) return targeted_paths # If all the files exist in the root directory, print out a success message if targeted_paths : typer . secho ( \"SUCCESS \\U0001F525 : All the file paths were\" \" successfully generated in the 'gatorgrade.yml' file!\" , fg = typer . colors . GREEN , ) return targeted_paths","title":"create_targeted_paths_list()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.generate_config","text":"Generate config by creating targeted paths in a list of strings, then create a YAML file. Source code in gatorgrade/generate/generate.py 136 137 138 139 def generate_config ( target_path_list : List [ str ], search_root : str = \".\" ): \"\"\"Generate config by creating targeted paths in a list of strings, then create a YAML file.\"\"\" targeted_paths = create_targeted_paths_list ( target_path_list , search_root ) write_yaml_of_paths_list ( targeted_paths , search_root )","title":"generate_config()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.input_correct","text":"Correct user-written paths. Source code in gatorgrade/generate/generate.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def input_correct ( initial_path_list : List [ str ], run_path : str ) -> Dict : \"\"\"Correct user-written paths.\"\"\" # Recognize the paths users provide are the concise versions. # Unify the ending format to avoid different users' different input corrected_path = [] # Run_path unify if run_path . endswith ( os . path . sep ) is False : run_path += os . path . sep for path in initial_path_list : # Combine the running path with the target path # To make sure the target path starts from the running directory path = run_path + path # Treat the last unit of the path as a concise name unit if path . endswith ( os . path . sep ) is False : path += os . path . sep corrected_path . append ( path ) # Convert list to dictionary for faster iteration return dict . fromkeys ( corrected_path , \"\" )","title":"input_correct()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.write_yaml_of_paths_list","text":"Write YAML file to create gatorgrade file and set default messages. Source code in gatorgrade/generate/generate.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def write_yaml_of_paths_list ( path_names : List [ str ], search_root : str ): # expected input: A path list \"\"\"Write YAML file to create gatorgrade file and set default messages.\"\"\" files_list = [] # Create an empty list to store dictionaries for file_path in path_names : # Iterate through items in path_names if file_path . endswith ( os . path . sep ): file_path = file_path [ 0 : - 1 ] # Convert file separators to '/' file_path_fixed = file_path . replace ( os . path . sep , \"/\" ) # Make file_path easier to read by removing unnecessary characters file_path_dict = { # Dictionary to store the file paths file_path_fixed : [ # List which stores strings which will be in gatorgrade.yml file { \"description\" : f \"Complete all TODOs in { file_path_fixed } \" , \"check\" : \"MatchFileFragment\" , \"options\" : { \"fragment\" : \"TODO\" , \"count\" : 0 , \"exact\" : True }, } ] } # Append files_list with the values stored inside file_path_dict files_list . append ( file_path_dict ) with open ( f \" { search_root }{ os . path . sep } gatorgrade.yml\" , \"w\" , encoding = \"utf-8\" ) as file : # Write a new YAML file named gatorgrade yaml . dump ( files_list , file , sort_keys = False )","title":"write_yaml_of_paths_list()"},{"location":"reference/input/checks/","text":"Define check classes. GatorGraderCheck Represent a GatorGrader check. Source code in gatorgrade/input/checks.py 20 21 22 23 24 25 26 27 28 29 class GatorGraderCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a GatorGrader check.\"\"\" def __init__ ( self , gg_args : List [ str ]): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. \"\"\" self . gg_args = gg_args __init__ ( gg_args ) Construct a GatorGraderCheck. Parameters: Name Type Description Default gg_args List [ str ] The list of arguments to pass to GatorGrader. required Source code in gatorgrade/input/checks.py 23 24 25 26 27 28 29 def __init__ ( self , gg_args : List [ str ]): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. \"\"\" self . gg_args = gg_args ShellCheck Represent a shell check. Source code in gatorgrade/input/checks.py 5 6 7 8 9 10 11 12 13 14 15 16 17 class ShellCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a shell check.\"\"\" def __init__ ( self , command : str , description : str = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. \"\"\" self . command = command self . description = description if description is not None else command __init__ ( command , description = None ) Construct a ShellCheck. Parameters: Name Type Description Default command str The command to run in a shell. required description str The description to use in output. If no description is given, the command is used as the description. None Source code in gatorgrade/input/checks.py 8 9 10 11 12 13 14 15 16 17 def __init__ ( self , command : str , description : str = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. \"\"\" self . command = command self . description = description if description is not None else command","title":"checks"},{"location":"reference/input/checks/#gatorgrade.input.checks.GatorGraderCheck","text":"Represent a GatorGrader check. Source code in gatorgrade/input/checks.py 20 21 22 23 24 25 26 27 28 29 class GatorGraderCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a GatorGrader check.\"\"\" def __init__ ( self , gg_args : List [ str ]): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. \"\"\" self . gg_args = gg_args","title":"GatorGraderCheck"},{"location":"reference/input/checks/#gatorgrade.input.checks.GatorGraderCheck.__init__","text":"Construct a GatorGraderCheck. Parameters: Name Type Description Default gg_args List [ str ] The list of arguments to pass to GatorGrader. required Source code in gatorgrade/input/checks.py 23 24 25 26 27 28 29 def __init__ ( self , gg_args : List [ str ]): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. \"\"\" self . gg_args = gg_args","title":"__init__()"},{"location":"reference/input/checks/#gatorgrade.input.checks.ShellCheck","text":"Represent a shell check. Source code in gatorgrade/input/checks.py 5 6 7 8 9 10 11 12 13 14 15 16 17 class ShellCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a shell check.\"\"\" def __init__ ( self , command : str , description : str = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. \"\"\" self . command = command self . description = description if description is not None else command","title":"ShellCheck"},{"location":"reference/input/checks/#gatorgrade.input.checks.ShellCheck.__init__","text":"Construct a ShellCheck. Parameters: Name Type Description Default command str The command to run in a shell. required description str The description to use in output. If no description is given, the command is used as the description. None Source code in gatorgrade/input/checks.py 8 9 10 11 12 13 14 15 16 17 def __init__ ( self , command : str , description : str = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. \"\"\" self . command = command self . description = description if description is not None else command","title":"__init__()"},{"location":"reference/input/command_line_generator/","text":"Generates a dictionary of shell and gator grader command options from a list of dict checks. generate_checks ( check_data_list ) Generate a list of checks based on check data from the configuration file. Parameters: Name Type Description Default check_data_list List [ CheckData ] A list of CheckData that each represent a check from the configuration file. required Returns: Type Description List [ Union [ ShellCheck , GatorGraderCheck ]] A list of ShellChecks and GatorGraderChecks. Source code in gatorgrade/input/command_line_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def generate_checks ( check_data_list : List [ CheckData ], ) -> List [ Union [ ShellCheck , GatorGraderCheck ]]: \"\"\"Generate a list of checks based on check data from the configuration file. Args: check_data_list: A list of CheckData that each represent a check from the configuration file. Returns: A list of ShellChecks and GatorGraderChecks. \"\"\" checks = [] for check_data in check_data_list : # If the check has a `command` key, then it is a shell check if \"command\" in check_data . check : checks . append ( ShellCheck ( command = check_data . check . get ( \"command\" ), description = check_data . check . get ( \"description\" ), ) ) # Otherwise, it is a GatorGrader check else : gg_args = [] # Add description option if in data description = check_data . check . get ( \"description\" ) if description is not None : gg_args . extend ([ \"--description\" , str ( description )]) # Always add name of check, which should be in data gg_args . append ( str ( check_data . check . get ( \"check\" ))) # Add any additional options options = check_data . check . get ( \"options\" ) if options is not None : for option in options : # If option should be a flag (i.e. its value is the `True` boolean), # add only the option without a value option_value = options [ option ] if isinstance ( option_value , bool ): if option_value : gg_args . append ( f \"-- { option } \" ) # Otherwise, add both the option and its value else : gg_args . extend ([ f \"-- { option } \" , str ( option_value )]) # Add directory and file if file context in data if check_data . file_context is not None : # Get the file and directory using os dirname , filename = os . path . split ( check_data . file_context ) if dirname == \"\" : dirname = \".\" gg_args . extend ([ \"--directory\" , dirname , \"--file\" , filename ]) checks . append ( GatorGraderCheck ( gg_args = gg_args )) return checks","title":"command_line_generator"},{"location":"reference/input/command_line_generator/#gatorgrade.input.command_line_generator.generate_checks","text":"Generate a list of checks based on check data from the configuration file. Parameters: Name Type Description Default check_data_list List [ CheckData ] A list of CheckData that each represent a check from the configuration file. required Returns: Type Description List [ Union [ ShellCheck , GatorGraderCheck ]] A list of ShellChecks and GatorGraderChecks. Source code in gatorgrade/input/command_line_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def generate_checks ( check_data_list : List [ CheckData ], ) -> List [ Union [ ShellCheck , GatorGraderCheck ]]: \"\"\"Generate a list of checks based on check data from the configuration file. Args: check_data_list: A list of CheckData that each represent a check from the configuration file. Returns: A list of ShellChecks and GatorGraderChecks. \"\"\" checks = [] for check_data in check_data_list : # If the check has a `command` key, then it is a shell check if \"command\" in check_data . check : checks . append ( ShellCheck ( command = check_data . check . get ( \"command\" ), description = check_data . check . get ( \"description\" ), ) ) # Otherwise, it is a GatorGrader check else : gg_args = [] # Add description option if in data description = check_data . check . get ( \"description\" ) if description is not None : gg_args . extend ([ \"--description\" , str ( description )]) # Always add name of check, which should be in data gg_args . append ( str ( check_data . check . get ( \"check\" ))) # Add any additional options options = check_data . check . get ( \"options\" ) if options is not None : for option in options : # If option should be a flag (i.e. its value is the `True` boolean), # add only the option without a value option_value = options [ option ] if isinstance ( option_value , bool ): if option_value : gg_args . append ( f \"-- { option } \" ) # Otherwise, add both the option and its value else : gg_args . extend ([ f \"-- { option } \" , str ( option_value )]) # Add directory and file if file context in data if check_data . file_context is not None : # Get the file and directory using os dirname , filename = os . path . split ( check_data . file_context ) if dirname == \"\" : dirname = \".\" gg_args . extend ([ \"--directory\" , dirname , \"--file\" , filename ]) checks . append ( GatorGraderCheck ( gg_args = gg_args )) return checks","title":"generate_checks()"},{"location":"reference/input/in_file_path/","text":"Generates a list of commands to be run through gatorgrader. add_checks_to_list ( path , data_list , reformatted_data ) Recursively loop through the data and add checks that are found to the reformatted list. Source code in gatorgrade/input/in_file_path.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def add_checks_to_list ( path , data_list , reformatted_data ) -> List [ CheckData ]: \"\"\"Recursively loop through the data and add checks that are found to the reformatted list.\"\"\" current_path = path # Saves the current path to keep track of the location for ddict in data_list : for item in ddict : if isinstance ( ddict [ item ], list ): # Checks if the current dictionary has another list as its value if not path : path = item else : path = f \" { path } / { item } \" add_checks_to_list ( path , ddict [ item ], reformatted_data ) # Runs this same function on the list inside of a dictionary path = current_path else : # Adds the current check to the reformatted data list reformatted_data . append ( CheckData ( file_context = path , check = ddict )) break parse_yaml_file ( file_path ) Parse a YAML file and return its contents as a list of dictionaries. Source code in gatorgrade/input/in_file_path.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def parse_yaml_file ( file_path : Path ) -> List [ Any ]: \"\"\"Parse a YAML file and return its contents as a list of dictionaries.\"\"\" # confirm that the file exists before attempting to read from it if file_path . exists (): # read the contents of the specified file using the default # encoding and then parse that file using the yaml package with open ( file_path , encoding = DEFAULT_ENCODING ) as file : # after parsing with the yaml module, return a list # of all of the contents specified in the file data = yaml . load_all ( file , Loader = yaml . FullLoader ) return list ( data ) # some aspect of the file does not exist # (i.e., wrong file or wrong directory) # and thus parsing with YAML is not possible; # return a blank list that calling function handles return [] reformat_yaml_data ( data ) Reformat the raw data from a YAML file into a list of tuples. Source code in gatorgrade/input/in_file_path.py 39 40 41 42 43 44 45 46 def reformat_yaml_data ( data ): \"\"\"Reformat the raw data from a YAML file into a list of tuples.\"\"\" reformatted_data = [] if len ( data ) == 2 : setup_commands = data . pop ( 0 ) # Removes the setup commands run_setup ( setup_commands ) add_checks_to_list ( None , data [ 0 ], reformatted_data ) return reformatted_data","title":"in_file_path"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.add_checks_to_list","text":"Recursively loop through the data and add checks that are found to the reformatted list. Source code in gatorgrade/input/in_file_path.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def add_checks_to_list ( path , data_list , reformatted_data ) -> List [ CheckData ]: \"\"\"Recursively loop through the data and add checks that are found to the reformatted list.\"\"\" current_path = path # Saves the current path to keep track of the location for ddict in data_list : for item in ddict : if isinstance ( ddict [ item ], list ): # Checks if the current dictionary has another list as its value if not path : path = item else : path = f \" { path } / { item } \" add_checks_to_list ( path , ddict [ item ], reformatted_data ) # Runs this same function on the list inside of a dictionary path = current_path else : # Adds the current check to the reformatted data list reformatted_data . append ( CheckData ( file_context = path , check = ddict )) break","title":"add_checks_to_list()"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.parse_yaml_file","text":"Parse a YAML file and return its contents as a list of dictionaries. Source code in gatorgrade/input/in_file_path.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def parse_yaml_file ( file_path : Path ) -> List [ Any ]: \"\"\"Parse a YAML file and return its contents as a list of dictionaries.\"\"\" # confirm that the file exists before attempting to read from it if file_path . exists (): # read the contents of the specified file using the default # encoding and then parse that file using the yaml package with open ( file_path , encoding = DEFAULT_ENCODING ) as file : # after parsing with the yaml module, return a list # of all of the contents specified in the file data = yaml . load_all ( file , Loader = yaml . FullLoader ) return list ( data ) # some aspect of the file does not exist # (i.e., wrong file or wrong directory) # and thus parsing with YAML is not possible; # return a blank list that calling function handles return []","title":"parse_yaml_file()"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.reformat_yaml_data","text":"Reformat the raw data from a YAML file into a list of tuples. Source code in gatorgrade/input/in_file_path.py 39 40 41 42 43 44 45 46 def reformat_yaml_data ( data ): \"\"\"Reformat the raw data from a YAML file into a list of tuples.\"\"\" reformatted_data = [] if len ( data ) == 2 : setup_commands = data . pop ( 0 ) # Removes the setup commands run_setup ( setup_commands ) add_checks_to_list ( None , data [ 0 ], reformatted_data ) return reformatted_data","title":"reformat_yaml_data()"},{"location":"reference/input/parse_config/","text":"Returns the list of commands to be run through gatorgrader. parse_config ( file ) Parse the input yaml file and generate specified checks. Parameters: Name Type Description Default file Path Yaml file containing gatorgrade and shell command checks required Returns: Type Description Returns a dictionary that specifies shell commands and gatorgrade commands Source code in gatorgrade/input/parse_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def parse_config ( file : Path ): \"\"\"Parse the input yaml file and generate specified checks. Args: file: Yaml file containing gatorgrade and shell command checks Returns: Returns a dictionary that specifies shell commands and gatorgrade commands \"\"\" # parse the YAML file using parse_yaml_file provided by gatorgrade parsed_yaml_file = parse_yaml_file ( file ) # the parsed YAML file contains some contents in a list and thus # the tool should generate a GatorGrader check for each element in list if len ( parsed_yaml_file ) > 0 : # after reformatting the parse YAML file, # use it to generate all of the checks; # these will be valid checks that are now # ready for execution with this tool parse_con = generate_checks ( reformat_yaml_data ( parsed_yaml_file )) return parse_con # return an empty list because of the fact that the # parsing process did not return a list with content; # allow the calling function to handle the empty list return []","title":"parse_config"},{"location":"reference/input/parse_config/#gatorgrade.input.parse_config.parse_config","text":"Parse the input yaml file and generate specified checks. Parameters: Name Type Description Default file Path Yaml file containing gatorgrade and shell command checks required Returns: Type Description Returns a dictionary that specifies shell commands and gatorgrade commands Source code in gatorgrade/input/parse_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def parse_config ( file : Path ): \"\"\"Parse the input yaml file and generate specified checks. Args: file: Yaml file containing gatorgrade and shell command checks Returns: Returns a dictionary that specifies shell commands and gatorgrade commands \"\"\" # parse the YAML file using parse_yaml_file provided by gatorgrade parsed_yaml_file = parse_yaml_file ( file ) # the parsed YAML file contains some contents in a list and thus # the tool should generate a GatorGrader check for each element in list if len ( parsed_yaml_file ) > 0 : # after reformatting the parse YAML file, # use it to generate all of the checks; # these will be valid checks that are now # ready for execution with this tool parse_con = generate_checks ( reformat_yaml_data ( parsed_yaml_file )) return parse_con # return an empty list because of the fact that the # parsing process did not return a list with content; # allow the calling function to handle the empty list return []","title":"parse_config()"},{"location":"reference/input/set_up_shell/","text":"Set-up the shell commands. run_setup ( front_matter ) Run the shell set up commands and exit the program if a command fails. Parameters: Name Type Description Default front_matter A dictionary whose 'setup' key contains the set up commands required Source code in gatorgrade/input/set_up_shell.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def run_setup ( front_matter ): \"\"\"Run the shell set up commands and exit the program if a command fails. Args: front_matter: A dictionary whose 'setup' key contains the set up commands as a multi-line string. \"\"\" # If setup exists in the front matter setup = front_matter . get ( \"setup\" ) if setup : typer . echo ( \"Running set up commands...\" ) for line in setup . splitlines (): # Trims the white space command = line . strip () # Executes the command proc = subprocess . run ( command , shell = True , check = False , timeout = 300 ) # If the exit code tells it was unsuccessful and did not return 0 if proc . returncode != 0 : typer . secho ( f 'The set up command \" { command } \" failed. \\ Exiting GatorGrade.' , err = True , fg = typer . colors . RED , ) # If a set up command failed, exit the execution # because environment was not set up correctly. raise typer . Exit ( 1 ) typer . echo ( \"Finished! \\n \" )","title":"set_up_shell"},{"location":"reference/input/set_up_shell/#gatorgrade.input.set_up_shell.run_setup","text":"Run the shell set up commands and exit the program if a command fails. Parameters: Name Type Description Default front_matter A dictionary whose 'setup' key contains the set up commands required Source code in gatorgrade/input/set_up_shell.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def run_setup ( front_matter ): \"\"\"Run the shell set up commands and exit the program if a command fails. Args: front_matter: A dictionary whose 'setup' key contains the set up commands as a multi-line string. \"\"\" # If setup exists in the front matter setup = front_matter . get ( \"setup\" ) if setup : typer . echo ( \"Running set up commands...\" ) for line in setup . splitlines (): # Trims the white space command = line . strip () # Executes the command proc = subprocess . run ( command , shell = True , check = False , timeout = 300 ) # If the exit code tells it was unsuccessful and did not return 0 if proc . returncode != 0 : typer . secho ( f 'The set up command \" { command } \" failed. \\ Exiting GatorGrade.' , err = True , fg = typer . colors . RED , ) # If a set up command failed, exit the execution # because environment was not set up correctly. raise typer . Exit ( 1 ) typer . echo ( \"Finished! \\n \" )","title":"run_setup()"},{"location":"reference/output/check_result/","text":"Define check result class. CheckResult Represent the result of running a check. Source code in gatorgrade/output/check_result.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class CheckResult : # pylint: disable=too-few-public-methods \"\"\"Represent the result of running a check.\"\"\" def __init__ ( self , passed : bool , description : str , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . diagnostic = diagnostic def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\uf00c\" if self . passed else \"\u2718\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message = f \"[yellow] \u2192 { self . diagnostic } \" return message def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result () rich . print ( message ) __init__ ( passed , description , diagnostic = 'No diagnostic message available' ) Construct a CheckResult. Parameters: Name Type Description Default passed bool The passed or failed status of the check result. If true, indicates that the check has passed. required description str The description to use in output. required diagnostic str The message to use in output if the check has failed. 'No diagnostic message available' Source code in gatorgrade/output/check_result.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , passed : bool , description : str , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . diagnostic = diagnostic __str__ ( show_diagnostic = False ) Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 42 43 44 45 46 47 48 49 50 51 52 def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message display_result ( show_diagnostic = False ) Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\uf00c\" if self . passed else \"\u2718\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message = f \"[yellow] \u2192 { self . diagnostic } \" return message print ( show_diagnostic = False ) Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 54 55 56 57 58 59 60 61 62 63 64 def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result () rich . print ( message )","title":"check_result"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult","text":"Represent the result of running a check. Source code in gatorgrade/output/check_result.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class CheckResult : # pylint: disable=too-few-public-methods \"\"\"Represent the result of running a check.\"\"\" def __init__ ( self , passed : bool , description : str , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . diagnostic = diagnostic def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\uf00c\" if self . passed else \"\u2718\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message = f \"[yellow] \u2192 { self . diagnostic } \" return message def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result () rich . print ( message )","title":"CheckResult"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.__init__","text":"Construct a CheckResult. Parameters: Name Type Description Default passed bool The passed or failed status of the check result. If true, indicates that the check has passed. required description str The description to use in output. required diagnostic str The message to use in output if the check has failed. 'No diagnostic message available' Source code in gatorgrade/output/check_result.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , passed : bool , description : str , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . diagnostic = diagnostic","title":"__init__()"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.__str__","text":"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 42 43 44 45 46 47 48 49 50 51 52 def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message","title":"__str__()"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.display_result","text":"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\uf00c\" if self . passed else \"\u2718\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message = f \"[yellow] \u2192 { self . diagnostic } \" return message","title":"display_result()"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.print","text":"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 54 55 56 57 58 59 60 61 62 63 64 def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result () rich . print ( message )","title":"print()"},{"location":"reference/output/output/","text":"Run checks and display whether each has passed or failed. _run_gg_check ( check ) Run a GatorGrader check. Parameters: Name Type Description Default check GatorGraderCheck The GatorGrader check to run. required Returns: Type Description CheckResult The result of running the GatorGrader check as a CheckResult. Source code in gatorgrade/output/output.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def _run_gg_check ( check : GatorGraderCheck ) -> CheckResult : \"\"\"Run a GatorGrader check. Args: check: The GatorGrader check to run. Returns: The result of running the GatorGrader check as a CheckResult. \"\"\" try : result = gator . grader ( check . gg_args ) passed = result [ 1 ] description = result [ 0 ] diagnostic = result [ 2 ] # If arguments are formatted incorrectly, catch the exception and # return it as the diagnostic message # Disable pylint to catch any type of exception thrown by GatorGrader except Exception as command_exception : # pylint: disable=W0703 passed = False description = f 'Invalid GatorGrader check: \" { \" \" . join ( check . gg_args ) } \"' diagnostic = f '\" { command_exception . __class__ } \" thrown by GatorGrader' return CheckResult ( passed = passed , description = description , diagnostic = diagnostic ) _run_shell_check ( check ) Run a shell check. Parameters: Name Type Description Default check ShellCheck The shell check to run. required Returns: Type Description CheckResult The result of running the shell check as a CheckResult. Source code in gatorgrade/output/output.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def _run_shell_check ( check : ShellCheck ) -> CheckResult : \"\"\"Run a shell check. Args: check: The shell check to run. Returns: The result of running the shell check as a CheckResult. \"\"\" result = subprocess . run ( check . command , shell = True , check = False , timeout = 300 , stdout = subprocess . PIPE , # Redirect STDERR to STDOUT so STDOUT and STDERR can be captured # together as diagnostic stderr = subprocess . STDOUT , ) passed = result . returncode == 0 diagnostic = ( \"\" if passed else result . stdout . decode () . strip () . replace ( \" \\n \" , \" \\n \" ) ) # Add spaces after each newline to indent all lines of diagnostic return CheckResult ( passed = passed , description = check . description , diagnostic = diagnostic ) print_with_border ( text , rich_color ) Print text with a border. Parameters: Name Type Description Default text str Text to print required rich_color str Color of text to print required Source code in gatorgrade/output/output.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def print_with_border ( text : str , rich_color : str ): \"\"\"Print text with a border. Args: text: Text to print rich_color: Color of text to print \"\"\" upleft = \" \\u250f \" # Upper left corner upright = \" \\u2513 \" # Upper right corner downleft = \" \\u2517 \" # Lower left corner downright = \" \\u251B \" # Lower right corner vert = \" \\u2503 \" # Vertical line horz = \" \\u2501 \" # Horizontal line line = horz * ( len ( text ) + 2 ) rich . print ( f \"[ { rich_color } ] \\n\\t { upleft }{ line }{ upright } \" ) rich . print ( f \"[ { rich_color } ] \\t { vert } { text } { vert } \" ) rich . print ( f \"[ { rich_color } ] \\t { downleft }{ line }{ downright } \\n \" ) run_checks ( checks ) Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Parameters: Name Type Description Default checks List [ Union [ ShellCheck , GatorGraderCheck ]] The list of shell and GatorGrader checks to run. required Source code in gatorgrade/output/output.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def run_checks ( checks : List [ Union [ ShellCheck , GatorGraderCheck ]]) -> bool : \"\"\"Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Args: checks: The list of shell and GatorGrader checks to run. \"\"\" results = [] # run each of the checks for check in checks : result = None # run a shell check; this means # that it is going to run a command # in the shell as a part of a check if isinstance ( check , ShellCheck ): result = _run_shell_check ( check ) # run a check that GatorGrader implements elif isinstance ( check , GatorGraderCheck ): result = _run_gg_check ( check ) # there were results from running checks # and thus they must be displayed if result is not None : result . print () results . append ( result ) # determine if there are failures and then display them failed_results = list ( filter ( lambda result : not result . passed , results )) # only print failures list if there are failures to print if len ( failed_results ) > 0 : print ( \" \\n -~- FAILURES -~- \\n \" ) for result in failed_results : result . print ( show_diagnostic = True ) # determine how many of the checks passed and then # compute the total percentage of checks passed passed_count = len ( results ) - len ( failed_results ) # prevent division by zero if no results if len ( results ) == 0 : percent = 0 else : percent = round ( passed_count / len ( results ) * 100 ) # compute summary results and display them in the console summary = f \"Passed { passed_count } / { len ( results ) } ( { percent } %) of checks for { Path . cwd () . name } !\" summary_color = \"green\" if passed_count == len ( results ) else \"bright white\" print_with_border ( summary , summary_color ) # determine whether or not the run was a success or not: # if all of the tests pass then the function returns True; # otherwise the function must return False summary_status = True if passed_count == len ( results ) else False return summary_status","title":"output"},{"location":"reference/output/output/#gatorgrade.output.output._run_gg_check","text":"Run a GatorGrader check. Parameters: Name Type Description Default check GatorGraderCheck The GatorGrader check to run. required Returns: Type Description CheckResult The result of running the GatorGrader check as a CheckResult. Source code in gatorgrade/output/output.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def _run_gg_check ( check : GatorGraderCheck ) -> CheckResult : \"\"\"Run a GatorGrader check. Args: check: The GatorGrader check to run. Returns: The result of running the GatorGrader check as a CheckResult. \"\"\" try : result = gator . grader ( check . gg_args ) passed = result [ 1 ] description = result [ 0 ] diagnostic = result [ 2 ] # If arguments are formatted incorrectly, catch the exception and # return it as the diagnostic message # Disable pylint to catch any type of exception thrown by GatorGrader except Exception as command_exception : # pylint: disable=W0703 passed = False description = f 'Invalid GatorGrader check: \" { \" \" . join ( check . gg_args ) } \"' diagnostic = f '\" { command_exception . __class__ } \" thrown by GatorGrader' return CheckResult ( passed = passed , description = description , diagnostic = diagnostic )","title":"_run_gg_check()"},{"location":"reference/output/output/#gatorgrade.output.output._run_shell_check","text":"Run a shell check. Parameters: Name Type Description Default check ShellCheck The shell check to run. required Returns: Type Description CheckResult The result of running the shell check as a CheckResult. Source code in gatorgrade/output/output.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def _run_shell_check ( check : ShellCheck ) -> CheckResult : \"\"\"Run a shell check. Args: check: The shell check to run. Returns: The result of running the shell check as a CheckResult. \"\"\" result = subprocess . run ( check . command , shell = True , check = False , timeout = 300 , stdout = subprocess . PIPE , # Redirect STDERR to STDOUT so STDOUT and STDERR can be captured # together as diagnostic stderr = subprocess . STDOUT , ) passed = result . returncode == 0 diagnostic = ( \"\" if passed else result . stdout . decode () . strip () . replace ( \" \\n \" , \" \\n \" ) ) # Add spaces after each newline to indent all lines of diagnostic return CheckResult ( passed = passed , description = check . description , diagnostic = diagnostic )","title":"_run_shell_check()"},{"location":"reference/output/output/#gatorgrade.output.output.print_with_border","text":"Print text with a border. Parameters: Name Type Description Default text str Text to print required rich_color str Color of text to print required Source code in gatorgrade/output/output.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def print_with_border ( text : str , rich_color : str ): \"\"\"Print text with a border. Args: text: Text to print rich_color: Color of text to print \"\"\" upleft = \" \\u250f \" # Upper left corner upright = \" \\u2513 \" # Upper right corner downleft = \" \\u2517 \" # Lower left corner downright = \" \\u251B \" # Lower right corner vert = \" \\u2503 \" # Vertical line horz = \" \\u2501 \" # Horizontal line line = horz * ( len ( text ) + 2 ) rich . print ( f \"[ { rich_color } ] \\n\\t { upleft }{ line }{ upright } \" ) rich . print ( f \"[ { rich_color } ] \\t { vert } { text } { vert } \" ) rich . print ( f \"[ { rich_color } ] \\t { downleft }{ line }{ downright } \\n \" )","title":"print_with_border()"},{"location":"reference/output/output/#gatorgrade.output.output.run_checks","text":"Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Parameters: Name Type Description Default checks List [ Union [ ShellCheck , GatorGraderCheck ]] The list of shell and GatorGrader checks to run. required Source code in gatorgrade/output/output.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def run_checks ( checks : List [ Union [ ShellCheck , GatorGraderCheck ]]) -> bool : \"\"\"Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Args: checks: The list of shell and GatorGrader checks to run. \"\"\" results = [] # run each of the checks for check in checks : result = None # run a shell check; this means # that it is going to run a command # in the shell as a part of a check if isinstance ( check , ShellCheck ): result = _run_shell_check ( check ) # run a check that GatorGrader implements elif isinstance ( check , GatorGraderCheck ): result = _run_gg_check ( check ) # there were results from running checks # and thus they must be displayed if result is not None : result . print () results . append ( result ) # determine if there are failures and then display them failed_results = list ( filter ( lambda result : not result . passed , results )) # only print failures list if there are failures to print if len ( failed_results ) > 0 : print ( \" \\n -~- FAILURES -~- \\n \" ) for result in failed_results : result . print ( show_diagnostic = True ) # determine how many of the checks passed and then # compute the total percentage of checks passed passed_count = len ( results ) - len ( failed_results ) # prevent division by zero if no results if len ( results ) == 0 : percent = 0 else : percent = round ( passed_count / len ( results ) * 100 ) # compute summary results and display them in the console summary = f \"Passed { passed_count } / { len ( results ) } ( { percent } %) of checks for { Path . cwd () . name } !\" summary_color = \"green\" if passed_count == len ( results ) else \"bright white\" print_with_border ( summary , summary_color ) # determine whether or not the run was a success or not: # if all of the tests pass then the function returns True; # otherwise the function must return False summary_status = True if passed_count == len ( results ) else False return summary_status","title":"run_checks()"}]}
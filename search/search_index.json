{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GatorGrade","title":"Home"},{"location":"#gatorgrade","text":"","title":"GatorGrade"},{"location":"reference/Summary/","text":"generate generate input command_line_generator in_file_path parse_config set_up_shell main output output_functions output_percentage_printing output_tools","title":"Summary"},{"location":"reference/main/","text":"Use Typer to run gatorgrade to run the checks and generate the yml file. gatorgrade ( ctx , filename = typer . Option ( FILE , '--config' , '-c' , help = 'Name of the yml file.' )) Run the GatorGrader checks in the gatorgrade.yml file. Source code in gatorgrade/main.py 11 12 13 14 15 16 17 18 19 20 @app . callback ( invoke_without_command = True ) def gatorgrade ( ctx : typer . Context , filename : Path = typer . Option ( FILE , \"--config\" , \"-c\" , help = \"Name of the yml file.\" ), ): \"\"\"Run the GatorGrader checks in the gatorgrade.yml file.\"\"\" # check if ctx.subcommand is none if ctx . invoked_subcommand is None : checks = parse_config ( filename ) run_and_display_command_checks ( checks ) generate () Generate a gatorgrade.yml file. Source code in gatorgrade/main.py 23 24 25 26 @app . command () def generate (): \"\"\"Generate a gatorgrade.yml file.\"\"\" pass # pylint: disable=unnecessary-pass","title":"main"},{"location":"reference/main/#gatorgrade.main.gatorgrade","text":"Run the GatorGrader checks in the gatorgrade.yml file. Source code in gatorgrade/main.py 11 12 13 14 15 16 17 18 19 20 @app . callback ( invoke_without_command = True ) def gatorgrade ( ctx : typer . Context , filename : Path = typer . Option ( FILE , \"--config\" , \"-c\" , help = \"Name of the yml file.\" ), ): \"\"\"Run the GatorGrader checks in the gatorgrade.yml file.\"\"\" # check if ctx.subcommand is none if ctx . invoked_subcommand is None : checks = parse_config ( filename ) run_and_display_command_checks ( checks )","title":"gatorgrade()"},{"location":"reference/main/#gatorgrade.main.generate","text":"Generate a gatorgrade.yml file. Source code in gatorgrade/main.py 23 24 25 26 @app . command () def generate (): \"\"\"Generate a gatorgrade.yml file.\"\"\" pass # pylint: disable=unnecessary-pass","title":"generate()"},{"location":"reference/generate/generate/","text":"Generate a YAML file with default messages and specific paths. create_targeted_paths_list ( target_path_list , relative_run_path = '.' ) Generate a list of targeted paths by walking the paths. Source code in gatorgrade/generate/generate.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def create_targeted_paths_list ( target_path_list : List [ str ], relative_run_path : str = \".\" ) -> List [ str ]: \"\"\"Generate a list of targeted paths by walking the paths.\"\"\" targeted_paths = [] corrected_paths = input_correct ( target_path_list ) # Go through the root repo, the sub dictionaries and files # The os.walk will only scan the paths # So the empty folders containing nothing won't be gone through for dirpath , _ , filenames in os . walk ( relative_run_path ): # Split path string into multiple layers of directories path_dir_list = dirpath . split ( os . path . sep ) # Ignore folder starting with double underscore if any ( path . startswith ( \"__\" ) for path in path_dir_list ): continue # Ignore hidden folders and first layer. the root repo is always dot # Keep double dot. It means going back to the parent folder if any ( path . startswith ( \".\" ) and not path . startswith ( \"..\" ) for path in path_dir_list [ 1 :] ): continue for filename in filenames : # Ignore special files if filename . startswith ( \"__\" ) or filename . startswith ( \".\" ): continue # Combine the path with file name to get a complete path complete_actual_path = os . path . join ( dirpath , filename ) + os . path . sep for target in corrected_paths : if target in complete_actual_path : polished_paths = complete_actual_path . replace ( f \".. { os . path . sep } \" , \"\" ) . replace ( f \". { os . path . sep } \" , \"\" ) targeted_paths . append ( polished_paths ) # If any of the user inputted file does not exist in any directory, # throw an exception indicating failure if not targeted_paths : raise FileNotFoundError ( f \" { FAIL } FAILURE: None of the user-provided file paths are\" + \" found in the provided directory and the 'gatorgrade.yml' is NOT generated\" ) # If some of the files are found and some are not found, # output a warning message saying which files were not found targeted_paths_string = \" \" . join ( targeted_paths ) for key in target_path_list : if key not in targeted_paths_string : print ( f \" { WARNING } WARNING \\N{Warning Sign} : ' { key } ' file path is not FOUND!\" + f \" \\n All file paths except ' { key } ' are successfully\" + \" generated in the 'gatorgrade.yml' file\" ) return targeted_paths # If all the files exist in the root directory, print out a success message if targeted_paths : print ( f \" { OKGREEN } SUCCESS \\N{Fire} : All the file paths were\" + \" successfully generated in the 'gatorgrade.yml' file!\" ) return targeted_paths generate_config ( target_path_list , search_root = '.' ) Generate config by creating targeted paths in a list of strings, then create a YAML file. Source code in gatorgrade/generate/generate.py 120 121 122 123 def generate_config ( target_path_list : List [ str ], search_root : str = \".\" ): \"\"\"Generate config by creating targeted paths in a list of strings, then create a YAML file.\"\"\" targeted_paths = create_targeted_paths_list ( target_path_list , search_root ) write_yaml_of_paths_list ( targeted_paths , search_root ) input_correct ( initial_path_list ) Correct user-written paths. Source code in gatorgrade/generate/generate.py 12 13 14 15 16 17 18 19 20 21 22 def input_correct ( initial_path_list : List [ str ]) -> Dict : \"\"\"Correct user-written paths.\"\"\" # Recognize the paths users provide are the concise versions. # Unify the ending format to avoid different users' different input corrected_path = [] for path in initial_path_list : if path . endswith ( os . path . sep ) is False : path += os . path . sep corrected_path . append ( path ) # Convert list to dictionary for faster iteration return dict . fromkeys ( corrected_path , \"\" ) write_yaml_of_paths_list ( path_names , search_root ) Write YAML file to create gatorgrade file and set default messages. Source code in gatorgrade/generate/generate.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def write_yaml_of_paths_list ( path_names , search_root ): # expected input: A path list \"\"\"Write YAML file to create gatorgrade file and set default messages.\"\"\" files_list = [] # Create an empty list to store dictionaries for file_path in path_names : # Iterate through items in path_names file_path_fixed = file_path . replace ( f \". { os . path . sep } \" , \"\" ) # Make file_path easier to read by removing unnecessary characters file_path_dict = { # Dictionary to store the file paths file_path_fixed : [ # List which stores strings which will be in gatorgrade.yml file { \"description\" : \"Complete all TODOs\" , \"check\" : \"MatchFileFragment\" , \"options\" : { \"fragment\" : \"TODO\" , \"count\" : 0 , \"exact\" : True }, } ] } # Append files_list with the values stored inside file_path_dict files_list . append ( file_path_dict ) with open ( f \" { search_root }{ os . path . sep } gatorgrade.yml\" , \"w\" , encoding = \"utf-8\" ) as file : # Write a new YAML file named gatorgrade yaml . dump ( files_list , file , sort_keys = False )","title":"generate"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.create_targeted_paths_list","text":"Generate a list of targeted paths by walking the paths. Source code in gatorgrade/generate/generate.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def create_targeted_paths_list ( target_path_list : List [ str ], relative_run_path : str = \".\" ) -> List [ str ]: \"\"\"Generate a list of targeted paths by walking the paths.\"\"\" targeted_paths = [] corrected_paths = input_correct ( target_path_list ) # Go through the root repo, the sub dictionaries and files # The os.walk will only scan the paths # So the empty folders containing nothing won't be gone through for dirpath , _ , filenames in os . walk ( relative_run_path ): # Split path string into multiple layers of directories path_dir_list = dirpath . split ( os . path . sep ) # Ignore folder starting with double underscore if any ( path . startswith ( \"__\" ) for path in path_dir_list ): continue # Ignore hidden folders and first layer. the root repo is always dot # Keep double dot. It means going back to the parent folder if any ( path . startswith ( \".\" ) and not path . startswith ( \"..\" ) for path in path_dir_list [ 1 :] ): continue for filename in filenames : # Ignore special files if filename . startswith ( \"__\" ) or filename . startswith ( \".\" ): continue # Combine the path with file name to get a complete path complete_actual_path = os . path . join ( dirpath , filename ) + os . path . sep for target in corrected_paths : if target in complete_actual_path : polished_paths = complete_actual_path . replace ( f \".. { os . path . sep } \" , \"\" ) . replace ( f \". { os . path . sep } \" , \"\" ) targeted_paths . append ( polished_paths ) # If any of the user inputted file does not exist in any directory, # throw an exception indicating failure if not targeted_paths : raise FileNotFoundError ( f \" { FAIL } FAILURE: None of the user-provided file paths are\" + \" found in the provided directory and the 'gatorgrade.yml' is NOT generated\" ) # If some of the files are found and some are not found, # output a warning message saying which files were not found targeted_paths_string = \" \" . join ( targeted_paths ) for key in target_path_list : if key not in targeted_paths_string : print ( f \" { WARNING } WARNING \\N{Warning Sign} : ' { key } ' file path is not FOUND!\" + f \" \\n All file paths except ' { key } ' are successfully\" + \" generated in the 'gatorgrade.yml' file\" ) return targeted_paths # If all the files exist in the root directory, print out a success message if targeted_paths : print ( f \" { OKGREEN } SUCCESS \\N{Fire} : All the file paths were\" + \" successfully generated in the 'gatorgrade.yml' file!\" ) return targeted_paths","title":"create_targeted_paths_list()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.generate_config","text":"Generate config by creating targeted paths in a list of strings, then create a YAML file. Source code in gatorgrade/generate/generate.py 120 121 122 123 def generate_config ( target_path_list : List [ str ], search_root : str = \".\" ): \"\"\"Generate config by creating targeted paths in a list of strings, then create a YAML file.\"\"\" targeted_paths = create_targeted_paths_list ( target_path_list , search_root ) write_yaml_of_paths_list ( targeted_paths , search_root )","title":"generate_config()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.input_correct","text":"Correct user-written paths. Source code in gatorgrade/generate/generate.py 12 13 14 15 16 17 18 19 20 21 22 def input_correct ( initial_path_list : List [ str ]) -> Dict : \"\"\"Correct user-written paths.\"\"\" # Recognize the paths users provide are the concise versions. # Unify the ending format to avoid different users' different input corrected_path = [] for path in initial_path_list : if path . endswith ( os . path . sep ) is False : path += os . path . sep corrected_path . append ( path ) # Convert list to dictionary for faster iteration return dict . fromkeys ( corrected_path , \"\" )","title":"input_correct()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.write_yaml_of_paths_list","text":"Write YAML file to create gatorgrade file and set default messages. Source code in gatorgrade/generate/generate.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def write_yaml_of_paths_list ( path_names , search_root ): # expected input: A path list \"\"\"Write YAML file to create gatorgrade file and set default messages.\"\"\" files_list = [] # Create an empty list to store dictionaries for file_path in path_names : # Iterate through items in path_names file_path_fixed = file_path . replace ( f \". { os . path . sep } \" , \"\" ) # Make file_path easier to read by removing unnecessary characters file_path_dict = { # Dictionary to store the file paths file_path_fixed : [ # List which stores strings which will be in gatorgrade.yml file { \"description\" : \"Complete all TODOs\" , \"check\" : \"MatchFileFragment\" , \"options\" : { \"fragment\" : \"TODO\" , \"count\" : 0 , \"exact\" : True }, } ] } # Append files_list with the values stored inside file_path_dict files_list . append ( file_path_dict ) with open ( f \" { search_root }{ os . path . sep } gatorgrade.yml\" , \"w\" , encoding = \"utf-8\" ) as file : # Write a new YAML file named gatorgrade yaml . dump ( files_list , file , sort_keys = False )","title":"write_yaml_of_paths_list()"},{"location":"reference/input/command_line_generator/","text":"Generates a dictionary of shell and gator grader command options from a list of dict checks. generate_checks ( file_context_checks ) Generate a dictionary of checks based on the configuration file. This dictionary will have the format: { \"shell\": List of shell checks, \"gatorgrader\": List of GatorGrader checks }, Parameters: Name Type Description Default file_context_checks List containing dictionaries that contain file contexts (either a file path or None if no file context) and checks in another dictionary (can be either GatorGrader or shell checks). The input list is generated based on the configuration file. required Source code in gatorgrade/input/command_line_generator.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def generate_checks ( file_context_checks ): \"\"\"Generate a dictionary of checks based on the configuration file. This dictionary will have the format: { \"shell\": List of shell checks, \"gatorgrader\": List of GatorGrader checks }, Args: file_context_checks: List containing dictionaries that contain file contexts (either a file path or None if no file context) and checks in another dictionary (can be either GatorGrader or shell checks). The input list is generated based on the configuration file. \"\"\" gatorgrader_checks = [] shell_checks = [] for file_context_check in file_context_checks : # assigning the check from the dict object check = file_context_check [ \"check\" ] # If the check has a 'command', then it is a shell check if \"command\" in check : shell_checks . append ( check ) # Else it's a GatorGrader check else : gatorgrader_command_options = [] # Defining the description and option description = check . get ( \"description\" ) options = check . get ( \"options\" ) if description is not None : # Creating a list that has description, check, and options for the check gatorgrader_command_options = [ \"--description\" , f \" { description } \" ] gatorgrader_command_options . append ( check [ \"check\" ]) # If options exist add all the keys and the values into GatorGrader command options if options is not None : for key in options : # Checking if the key is a flag if isinstance ( options [ key ], bool ): if options [ key ] is True : gatorgrader_command_options . append ( f \"-- { key } \" ) # Else if it's not a flag, then adding both key and values else : gatorgrader_command_options . append ( f \"-- { key } \" ) gatorgrader_command_options . append ( f \" { options [ key ] } \" ) # assigning the file context from the dict object file_context = file_context_check [ \"file_context\" ] # If it is a gator grade check with a file context, # then add the directory and the file name into the command options if file_context is not None : # Get the file and directory using os dirname , filename = os . path . split ( file_context ) if dirname == \"\" : dirname = \".\" gatorgrader_command_options . append ( \"--directory\" ) gatorgrader_command_options . append ( f \" { dirname } \" ) gatorgrader_command_options . append ( \"--file\" ) gatorgrader_command_options . append ( f \" { filename } \" ) # Add the contents inside the temporary list into the final GatorGrader list. gatorgrader_checks . append ( gatorgrader_command_options ) return { \"shell\" : shell_checks , \"gatorgrader\" : gatorgrader_checks }","title":"command_line_generator"},{"location":"reference/input/command_line_generator/#gatorgrade.input.command_line_generator.generate_checks","text":"Generate a dictionary of checks based on the configuration file. This dictionary will have the format: { \"shell\": List of shell checks, \"gatorgrader\": List of GatorGrader checks }, Parameters: Name Type Description Default file_context_checks List containing dictionaries that contain file contexts (either a file path or None if no file context) and checks in another dictionary (can be either GatorGrader or shell checks). The input list is generated based on the configuration file. required Source code in gatorgrade/input/command_line_generator.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def generate_checks ( file_context_checks ): \"\"\"Generate a dictionary of checks based on the configuration file. This dictionary will have the format: { \"shell\": List of shell checks, \"gatorgrader\": List of GatorGrader checks }, Args: file_context_checks: List containing dictionaries that contain file contexts (either a file path or None if no file context) and checks in another dictionary (can be either GatorGrader or shell checks). The input list is generated based on the configuration file. \"\"\" gatorgrader_checks = [] shell_checks = [] for file_context_check in file_context_checks : # assigning the check from the dict object check = file_context_check [ \"check\" ] # If the check has a 'command', then it is a shell check if \"command\" in check : shell_checks . append ( check ) # Else it's a GatorGrader check else : gatorgrader_command_options = [] # Defining the description and option description = check . get ( \"description\" ) options = check . get ( \"options\" ) if description is not None : # Creating a list that has description, check, and options for the check gatorgrader_command_options = [ \"--description\" , f \" { description } \" ] gatorgrader_command_options . append ( check [ \"check\" ]) # If options exist add all the keys and the values into GatorGrader command options if options is not None : for key in options : # Checking if the key is a flag if isinstance ( options [ key ], bool ): if options [ key ] is True : gatorgrader_command_options . append ( f \"-- { key } \" ) # Else if it's not a flag, then adding both key and values else : gatorgrader_command_options . append ( f \"-- { key } \" ) gatorgrader_command_options . append ( f \" { options [ key ] } \" ) # assigning the file context from the dict object file_context = file_context_check [ \"file_context\" ] # If it is a gator grade check with a file context, # then add the directory and the file name into the command options if file_context is not None : # Get the file and directory using os dirname , filename = os . path . split ( file_context ) if dirname == \"\" : dirname = \".\" gatorgrader_command_options . append ( \"--directory\" ) gatorgrader_command_options . append ( f \" { dirname } \" ) gatorgrader_command_options . append ( \"--file\" ) gatorgrader_command_options . append ( f \" { filename } \" ) # Add the contents inside the temporary list into the final GatorGrader list. gatorgrader_checks . append ( gatorgrader_command_options ) return { \"shell\" : shell_checks , \"gatorgrader\" : gatorgrader_checks }","title":"generate_checks()"},{"location":"reference/input/in_file_path/","text":"Generates a list of commands to be run through gatorgrader. add_checks_to_list ( path , data_list , reformatted_data ) Recursively loop through the data and add checks that are found to the reformatted list. Source code in gatorgrade/input/in_file_path.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def add_checks_to_list ( path , data_list , reformatted_data ): \"\"\"Recursively loop through the data and add checks that are found to the reformatted list.\"\"\" current_path = path # Saves the current path to keep track of the location for ddict in data_list : for item in ddict : if isinstance ( ddict [ item ], list ): # Checks if the current dictionary has another list as its value if not path : path = item else : path = f \" { path } / { item } \" add_checks_to_list ( path , ddict [ item ], reformatted_data ) # Runs this same function on the list inside of a dictionary path = current_path else : # Adds the current check to the reformatted data list reformatted_data . append ({ \"file_context\" : path , \"check\" : ddict }) break parse_yaml_file ( file_path ) Parse a YAML file and return its contents as a list of dictionaries. Source code in gatorgrade/input/in_file_path.py 6 7 8 9 10 def parse_yaml_file ( file_path ): \"\"\"Parse a YAML file and return its contents as a list of dictionaries.\"\"\" with open ( file_path , encoding = \"utf8\" ) as file : data = yaml . load_all ( file , Loader = yaml . FullLoader ) return list ( data ) reformat_yaml_data ( data ) Reformat the raw data from a YAML file into a list of tuples. Source code in gatorgrade/input/in_file_path.py 13 14 15 16 17 18 19 20 def reformat_yaml_data ( data ): \"\"\"Reformat the raw data from a YAML file into a list of tuples.\"\"\" reformatted_data = [] if len ( data ) == 2 : setup_commands = data . pop ( 0 ) # Removes the setup commands run_setup ( setup_commands ) add_checks_to_list ( None , data [ 0 ], reformatted_data ) return reformatted_data","title":"in_file_path"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.add_checks_to_list","text":"Recursively loop through the data and add checks that are found to the reformatted list. Source code in gatorgrade/input/in_file_path.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def add_checks_to_list ( path , data_list , reformatted_data ): \"\"\"Recursively loop through the data and add checks that are found to the reformatted list.\"\"\" current_path = path # Saves the current path to keep track of the location for ddict in data_list : for item in ddict : if isinstance ( ddict [ item ], list ): # Checks if the current dictionary has another list as its value if not path : path = item else : path = f \" { path } / { item } \" add_checks_to_list ( path , ddict [ item ], reformatted_data ) # Runs this same function on the list inside of a dictionary path = current_path else : # Adds the current check to the reformatted data list reformatted_data . append ({ \"file_context\" : path , \"check\" : ddict }) break","title":"add_checks_to_list()"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.parse_yaml_file","text":"Parse a YAML file and return its contents as a list of dictionaries. Source code in gatorgrade/input/in_file_path.py 6 7 8 9 10 def parse_yaml_file ( file_path ): \"\"\"Parse a YAML file and return its contents as a list of dictionaries.\"\"\" with open ( file_path , encoding = \"utf8\" ) as file : data = yaml . load_all ( file , Loader = yaml . FullLoader ) return list ( data )","title":"parse_yaml_file()"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.reformat_yaml_data","text":"Reformat the raw data from a YAML file into a list of tuples. Source code in gatorgrade/input/in_file_path.py 13 14 15 16 17 18 19 20 def reformat_yaml_data ( data ): \"\"\"Reformat the raw data from a YAML file into a list of tuples.\"\"\" reformatted_data = [] if len ( data ) == 2 : setup_commands = data . pop ( 0 ) # Removes the setup commands run_setup ( setup_commands ) add_checks_to_list ( None , data [ 0 ], reformatted_data ) return reformatted_data","title":"reformat_yaml_data()"},{"location":"reference/input/parse_config/","text":"Returns the list of commands to be run through gatorgrader. parse_config ( file ) Parse the input yaml file and generate specified checks. Parameters: Name Type Description Default file Yaml file containing gatorgrade and shell command checks required Returns: Type Description Returns a dictionary that specifies shell commands and gatorgrade commands Source code in gatorgrade/input/parse_config.py 11 12 13 14 15 16 17 18 19 20 21 22 def parse_config ( file ): \"\"\"Parse the input yaml file and generate specified checks. Args: file: Yaml file containing gatorgrade and shell command checks Returns: Returns a dictionary that specifies shell commands and gatorgrade commands \"\"\" parse_con = generate_checks ( reformat_yaml_data ( parse_yaml_file ( file )) ) # Call previously generated function to modify file return parse_con","title":"parse_config"},{"location":"reference/input/parse_config/#gatorgrade.input.parse_config.parse_config","text":"Parse the input yaml file and generate specified checks. Parameters: Name Type Description Default file Yaml file containing gatorgrade and shell command checks required Returns: Type Description Returns a dictionary that specifies shell commands and gatorgrade commands Source code in gatorgrade/input/parse_config.py 11 12 13 14 15 16 17 18 19 20 21 22 def parse_config ( file ): \"\"\"Parse the input yaml file and generate specified checks. Args: file: Yaml file containing gatorgrade and shell command checks Returns: Returns a dictionary that specifies shell commands and gatorgrade commands \"\"\" parse_con = generate_checks ( reformat_yaml_data ( parse_yaml_file ( file )) ) # Call previously generated function to modify file return parse_con","title":"parse_config()"},{"location":"reference/input/set_up_shell/","text":"Set-up the shell commands. run_setup ( front_matter ) Run the shell set up commands and exit the program if a command fails. Parameters: Name Type Description Default front_matter A dictionary whose 'setup' key contains the set up commands required Source code in gatorgrade/input/set_up_shell.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def run_setup ( front_matter ): \"\"\"Run the shell set up commands and exit the program if a command fails. Args: front_matter: A dictionary whose 'setup' key contains the set up commands as a multi-line string. \"\"\" # If setup exists in the front matter setup = front_matter . get ( \"setup\" ) if setup : print ( \"Running set up commands...\" ) for line in setup . splitlines (): # Trims the white space command = line . strip () # Executes the command proc = subprocess . run ( command , shell = True , check = False , timeout = 300 ) # If the exit code tells it was unsuccessful and did not return 0 if proc . returncode != 0 : print ( f 'The set up command \" { command } \" failed. \\ Exiting GatorGrade.' , file = sys . stderr , ) # If a set up command failed, exit the execution # because environment was not set up correctly. sys . exit ( 1 ) print ( \"Finished! \\n \" )","title":"set_up_shell"},{"location":"reference/input/set_up_shell/#gatorgrade.input.set_up_shell.run_setup","text":"Run the shell set up commands and exit the program if a command fails. Parameters: Name Type Description Default front_matter A dictionary whose 'setup' key contains the set up commands required Source code in gatorgrade/input/set_up_shell.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def run_setup ( front_matter ): \"\"\"Run the shell set up commands and exit the program if a command fails. Args: front_matter: A dictionary whose 'setup' key contains the set up commands as a multi-line string. \"\"\" # If setup exists in the front matter setup = front_matter . get ( \"setup\" ) if setup : print ( \"Running set up commands...\" ) for line in setup . splitlines (): # Trims the white space command = line . strip () # Executes the command proc = subprocess . run ( command , shell = True , check = False , timeout = 300 ) # If the exit code tells it was unsuccessful and did not return 0 if proc . returncode != 0 : print ( f 'The set up command \" { command } \" failed. \\ Exiting GatorGrade.' , file = sys . stderr , ) # If a set up command failed, exit the execution # because environment was not set up correctly. sys . exit ( 1 ) print ( \"Finished! \\n \" )","title":"run_setup()"},{"location":"reference/output/output_functions/","text":"This module is used for storing the main functions requested. The requested functions are located at the Github Issue Tracker for the output team. For instance, functions dealing with percentage output, description output, and colorization of text. display_check_results ( results ) Process results and determine if the check passed or failed. Parameters: Name Type Description Default results list[(description, passed, diagnostic),(...)] required Source code in gatorgrade/output/output_functions.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def display_check_results ( results ): \"\"\" Process results and determine if the check passed or failed. Args: results: list[(description, passed, diagnostic),(...)] \"\"\" passed_checks = [] failed_checks = [] # Iterate through results tuples for result in results : # Add passing checks to the passed check list and failing checks to # the failed check list if result [ 1 ] is True : passed_checks . append ( result ) else : failed_checks . append ( result ) output_passed_checks ( passed_checks ) output_failed_checks ( failed_checks ) output_failed_checks ( failed_checks ) Output the results for all of the checks that did not pass using the failed_checks list. Source code in gatorgrade/output/output_functions.py 91 92 93 94 95 96 97 98 99 100 def output_failed_checks ( failed_checks ): \"\"\"Output the results for all of the checks that did not pass using the failed_checks list.\"\"\" for check in failed_checks : # Extract the details of each check requirement = check [ 0 ] description = check [ 2 ] # Use colorama to print and style \"X\" print ( f \" { color . Fore . RED } \\u2718 { color . Style . RESET_ALL }{ requirement } \" ) print ( f \" { color . Fore . YELLOW } \\u2192 { description } \" ) return bool output_passed_checks ( passed_checks ) Output the results for all of the checks that passed using the passed_checks list. Source code in gatorgrade/output/output_functions.py 83 84 85 86 87 88 def output_passed_checks ( passed_checks ): \"\"\"Output the results for all of the checks that passed using the passed_checks list.\"\"\" for check in passed_checks : requirement = check [ 0 ] # Use colorama to style passing check print ( f \" { color . Fore . GREEN } \\u2714 { color . Style . RESET_ALL }{ requirement } \" ) run_and_display_command_checks ( commands ) Run commands through GatorGrader and display them to the user. Parameters: Name Type Description Default commands_input dict{str List[dict{str:str, ...}], required str List[List[str]]}): The first parameter which required An Example of arg input for this function is as follows required {'shell' [{'description': 'Run program', 'command': 'mdl'}], required 'gatorgrader' [['--description', 'do command', 'commandType', required Source code in gatorgrade/output/output_functions.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def run_and_display_command_checks ( commands ): \"\"\"Run commands through GatorGrader and display them to the user. Args: Commands are received as dictionary of two keys, shell commands / gator commands. commands_input (dict{str: List[dict{str:str, ...}], str: List[List[str]]}): The first parameter which contains commands. An Example of arg input for this function is as follows : {'shell': [{'description': 'Run program', 'command': 'mdl'}], 'gatorgrader': [['--description', 'do command', 'commandType', '--arg', '1', '--directory', './home', '--file', 'file.py']]} \"\"\" results = run_commands_and_return_results ( commands ) display_check_results ( results ) print ( output_percentage_printing . print_percentage ( results )) run_commands_and_return_results ( commands_input ) Run commands through GatorGrader and send results to other output methods. Parameters: Name Type Description Default commands_input dict{str List[dict{str:str, ...}], required str List[List[str]]}): The first parameter which required An Example of arg input for this function is as follows required {'shell' [{'description': 'Run program', 'command': 'mdl'}], required 'gatorgrader' [['--description', 'do command', 'commandType', required Returns: Type Description List[tuple(str, bool, str)] Each tuple in the list is the result of a specific command being run. The first string is the description which comes directly from the command. The boolean describes whether the command passed or failed the check. The final string will either a diagnostic for a failed check or a blank string for a passed check. Source code in gatorgrade/output/output_functions.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def run_commands_and_return_results ( commands_input ): \"\"\"Run commands through GatorGrader and send results to other output methods. Args: Commands are received as dictionary of two keys, shell commands / gator commands. commands_input (dict{str: List[dict{str:str, ...}], str: List[List[str]]}): The first parameter which contains commands. An Example of arg input for this function is as follows : {'shell': [{'description': 'Run program', 'command': 'mdl'}], 'gatorgrader': [['--description', 'do command', 'commandType', '--arg', '1', '--directory', './home', '--file', 'file.py']]} Returns: List[tuple(str, bool, str)] Each tuple in the list is the result of a specific command being run. The first string is the description which comes directly from the command. The boolean describes whether the command passed or failed the check. The final string will either a diagnostic for a failed check or a blank string for a passed check. \"\"\" # Get first element in list, which is gatorgrader commands gatorcommands = commands_input . get ( \"gatorgrader\" ) results = [] for command in gatorcommands : # If command is formatted incorrectly in yaml files, # catch the exception that would be returned and print try : result = gator . grader ( command ) # disable pylint so the more general Exception class can be used except Exception as command_exception : # pylint: disable=W0703 bad_command = command_exception . __class__ result = ( command , False , bad_command ) results . append ( result ) return results","title":"output_functions"},{"location":"reference/output/output_functions/#gatorgrade.output.output_functions.display_check_results","text":"Process results and determine if the check passed or failed. Parameters: Name Type Description Default results list[(description, passed, diagnostic),(...)] required Source code in gatorgrade/output/output_functions.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def display_check_results ( results ): \"\"\" Process results and determine if the check passed or failed. Args: results: list[(description, passed, diagnostic),(...)] \"\"\" passed_checks = [] failed_checks = [] # Iterate through results tuples for result in results : # Add passing checks to the passed check list and failing checks to # the failed check list if result [ 1 ] is True : passed_checks . append ( result ) else : failed_checks . append ( result ) output_passed_checks ( passed_checks ) output_failed_checks ( failed_checks )","title":"display_check_results()"},{"location":"reference/output/output_functions/#gatorgrade.output.output_functions.output_failed_checks","text":"Output the results for all of the checks that did not pass using the failed_checks list. Source code in gatorgrade/output/output_functions.py 91 92 93 94 95 96 97 98 99 100 def output_failed_checks ( failed_checks ): \"\"\"Output the results for all of the checks that did not pass using the failed_checks list.\"\"\" for check in failed_checks : # Extract the details of each check requirement = check [ 0 ] description = check [ 2 ] # Use colorama to print and style \"X\" print ( f \" { color . Fore . RED } \\u2718 { color . Style . RESET_ALL }{ requirement } \" ) print ( f \" { color . Fore . YELLOW } \\u2192 { description } \" ) return bool","title":"output_failed_checks()"},{"location":"reference/output/output_functions/#gatorgrade.output.output_functions.output_passed_checks","text":"Output the results for all of the checks that passed using the passed_checks list. Source code in gatorgrade/output/output_functions.py 83 84 85 86 87 88 def output_passed_checks ( passed_checks ): \"\"\"Output the results for all of the checks that passed using the passed_checks list.\"\"\" for check in passed_checks : requirement = check [ 0 ] # Use colorama to style passing check print ( f \" { color . Fore . GREEN } \\u2714 { color . Style . RESET_ALL }{ requirement } \" )","title":"output_passed_checks()"},{"location":"reference/output/output_functions/#gatorgrade.output.output_functions.run_and_display_command_checks","text":"Run commands through GatorGrader and display them to the user. Parameters: Name Type Description Default commands_input dict{str List[dict{str:str, ...}], required str List[List[str]]}): The first parameter which required An Example of arg input for this function is as follows required {'shell' [{'description': 'Run program', 'command': 'mdl'}], required 'gatorgrader' [['--description', 'do command', 'commandType', required Source code in gatorgrade/output/output_functions.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def run_and_display_command_checks ( commands ): \"\"\"Run commands through GatorGrader and display them to the user. Args: Commands are received as dictionary of two keys, shell commands / gator commands. commands_input (dict{str: List[dict{str:str, ...}], str: List[List[str]]}): The first parameter which contains commands. An Example of arg input for this function is as follows : {'shell': [{'description': 'Run program', 'command': 'mdl'}], 'gatorgrader': [['--description', 'do command', 'commandType', '--arg', '1', '--directory', './home', '--file', 'file.py']]} \"\"\" results = run_commands_and_return_results ( commands ) display_check_results ( results ) print ( output_percentage_printing . print_percentage ( results ))","title":"run_and_display_command_checks()"},{"location":"reference/output/output_functions/#gatorgrade.output.output_functions.run_commands_and_return_results","text":"Run commands through GatorGrader and send results to other output methods. Parameters: Name Type Description Default commands_input dict{str List[dict{str:str, ...}], required str List[List[str]]}): The first parameter which required An Example of arg input for this function is as follows required {'shell' [{'description': 'Run program', 'command': 'mdl'}], required 'gatorgrader' [['--description', 'do command', 'commandType', required Returns: Type Description List[tuple(str, bool, str)] Each tuple in the list is the result of a specific command being run. The first string is the description which comes directly from the command. The boolean describes whether the command passed or failed the check. The final string will either a diagnostic for a failed check or a blank string for a passed check. Source code in gatorgrade/output/output_functions.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def run_commands_and_return_results ( commands_input ): \"\"\"Run commands through GatorGrader and send results to other output methods. Args: Commands are received as dictionary of two keys, shell commands / gator commands. commands_input (dict{str: List[dict{str:str, ...}], str: List[List[str]]}): The first parameter which contains commands. An Example of arg input for this function is as follows : {'shell': [{'description': 'Run program', 'command': 'mdl'}], 'gatorgrader': [['--description', 'do command', 'commandType', '--arg', '1', '--directory', './home', '--file', 'file.py']]} Returns: List[tuple(str, bool, str)] Each tuple in the list is the result of a specific command being run. The first string is the description which comes directly from the command. The boolean describes whether the command passed or failed the check. The final string will either a diagnostic for a failed check or a blank string for a passed check. \"\"\" # Get first element in list, which is gatorgrader commands gatorcommands = commands_input . get ( \"gatorgrader\" ) results = [] for command in gatorcommands : # If command is formatted incorrectly in yaml files, # catch the exception that would be returned and print try : result = gator . grader ( command ) # disable pylint so the more general Exception class can be used except Exception as command_exception : # pylint: disable=W0703 bad_command = command_exception . __class__ result = ( command , False , bad_command ) results . append ( result ) return results","title":"run_commands_and_return_results()"},{"location":"reference/output/output_percentage_printing/","text":"Output with the percentage of checks that the student has met requirments. print_percentage ( results ) Print percentage acts as fuction that will produce the output. Source code in gatorgrade/output/output_percentage_printing.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def print_percentage ( results ): \"\"\"Print percentage acts as fuction that will produce the output.\"\"\" # iterate through results tuples true_list = [] # empty list for storing true results for result in results : if result [ 1 ] is True : true_list . append ( result ) math = len ( true_list ) / len ( results ) # procedure of math right/total percent = math * 100 # get the percent to non decimal. if percent == 100.0 : return ( f \" { Fore . GREEN } |=====================================| \\n \" + f \"|Passing all GatorGrader Checks { percent } %| \\n \" + \"|=====================================|\" ) return ( f \" \\n { Fore . RED } Passing { len ( true_list ) } / { len ( results ) } , Grade is { percent } %. \\n \" )","title":"output_percentage_printing"},{"location":"reference/output/output_percentage_printing/#gatorgrade.output.output_percentage_printing.print_percentage","text":"Print percentage acts as fuction that will produce the output. Source code in gatorgrade/output/output_percentage_printing.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def print_percentage ( results ): \"\"\"Print percentage acts as fuction that will produce the output.\"\"\" # iterate through results tuples true_list = [] # empty list for storing true results for result in results : if result [ 1 ] is True : true_list . append ( result ) math = len ( true_list ) / len ( results ) # procedure of math right/total percent = math * 100 # get the percent to non decimal. if percent == 100.0 : return ( f \" { Fore . GREEN } |=====================================| \\n \" + f \"|Passing all GatorGrader Checks { percent } %| \\n \" + \"|=====================================|\" ) return ( f \" \\n { Fore . RED } Passing { len ( true_list ) } / { len ( results ) } , Grade is { percent } %. \\n \" )","title":"print_percentage()"},{"location":"reference/output/output_tools/","text":"This file is used for storing supporting functions and tools. These functions and tools are used by the methods in output_functions. The main use of this class is to de-clutter output_functions.py for better readability. One example of a function to be written here is the splitting of strings retrieved from the input team, at spaces, into lists.","title":"output_tools"}]}
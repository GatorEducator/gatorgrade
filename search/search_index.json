{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GatorGrade","title":"Home"},{"location":"#gatorgrade","text":"","title":"GatorGrade"},{"location":"reference/Summary/","text":"generate generate input checks command_line_generator in_file_path parse_config set_up_shell main output check_result output","title":"Summary"},{"location":"reference/main/","text":"Use Typer to run gatorgrade to run the checks and generate the yml file. gatorgrade ( ctx , filename = typer . Option ( FILE , '--config' , '-c' , help = 'Name of the yml file.' ), report = typer . Option (( None , None , None ), '--report' , '-r' , help = \"A tuple containing the following REQUIRED values: 1. The destination of the report (either file or env) 2. The format of the report (either json or md) 3. the name of the file or environment variable 4. use 'env md GITHUB_STEP_SUMMARY' to create GitHub job summary in GitHub Action\" )) Run the GatorGrader checks in the specified gatorgrade.yml file. Source code in gatorgrade/main.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @app . callback ( invoke_without_command = True ) def gatorgrade ( ctx : typer . Context , filename : Path = typer . Option ( FILE , \"--config\" , \"-c\" , help = \"Name of the yml file.\" ), report : Tuple [ str , str , str ] = typer . Option ( ( None , None , None ), \"--report\" , \"-r\" , help = \"A tuple containing the following REQUIRED values: \\ 1. The destination of the report (either file or env) \\ 2. The format of the report (either json or md) \\ 3. the name of the file or environment variable \\ 4. use 'env md GITHUB_STEP_SUMMARY' to create GitHub job summary in GitHub Action\" , ), ): \"\"\"Run the GatorGrader checks in the specified gatorgrade.yml file.\"\"\" # if ctx.subcommand is None then this means # that, by default, gatorgrade should run in checking mode if ctx . invoked_subcommand is None : # parse the provided configuration file checks = parse_config ( filename ) # there are valid checks and thus the # tool should run them with run_checks if len ( checks ) > 0 : checks_status = run_checks ( checks , report ) # no checks were created and this means # that, most likely, the file was not # valid and thus the tool cannot run checks else : checks_status = False console . print () console . print ( f \"The file { filename } either does not exist or is not valid.\" ) console . print ( \"Exiting now!\" ) console . print () # at least one of the checks did not pass or # the provided file was not valid and thus # the tool should return a non-zero exit # code to designate some type of failure if checks_status is not True : sys . exit ( FAILURE )","title":"main"},{"location":"reference/main/#gatorgrade.main.gatorgrade","text":"Run the GatorGrader checks in the specified gatorgrade.yml file. Source code in gatorgrade/main.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @app . callback ( invoke_without_command = True ) def gatorgrade ( ctx : typer . Context , filename : Path = typer . Option ( FILE , \"--config\" , \"-c\" , help = \"Name of the yml file.\" ), report : Tuple [ str , str , str ] = typer . Option ( ( None , None , None ), \"--report\" , \"-r\" , help = \"A tuple containing the following REQUIRED values: \\ 1. The destination of the report (either file or env) \\ 2. The format of the report (either json or md) \\ 3. the name of the file or environment variable \\ 4. use 'env md GITHUB_STEP_SUMMARY' to create GitHub job summary in GitHub Action\" , ), ): \"\"\"Run the GatorGrader checks in the specified gatorgrade.yml file.\"\"\" # if ctx.subcommand is None then this means # that, by default, gatorgrade should run in checking mode if ctx . invoked_subcommand is None : # parse the provided configuration file checks = parse_config ( filename ) # there are valid checks and thus the # tool should run them with run_checks if len ( checks ) > 0 : checks_status = run_checks ( checks , report ) # no checks were created and this means # that, most likely, the file was not # valid and thus the tool cannot run checks else : checks_status = False console . print () console . print ( f \"The file { filename } either does not exist or is not valid.\" ) console . print ( \"Exiting now!\" ) console . print () # at least one of the checks did not pass or # the provided file was not valid and thus # the tool should return a non-zero exit # code to designate some type of failure if checks_status is not True : sys . exit ( FAILURE )","title":"gatorgrade()"},{"location":"reference/generate/generate/","text":"Generate a YAML file with default messages and specific paths. create_targeted_paths_list ( target_path_list , relative_run_path = '.' ) Generate a list of targeted paths by walking the paths. Source code in gatorgrade/generate/generate.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def create_targeted_paths_list ( target_path_list : List [ str ], relative_run_path : str = \".\" ) -> List [ str ]: \"\"\"Generate a list of targeted paths by walking the paths.\"\"\" targeted_paths = [] corrected_paths = input_correct ( target_path_list , relative_run_path ) # Go through the root repo, the sub dictionaries and files # The os.walk will only scan the paths # So the empty folders containing nothing won't be gone through for dirpath , _ , filenames in os . walk ( relative_run_path ): # Split path string into multiple layers of directories path_dir_list = dirpath . split ( os . path . sep ) # Ignore folder starting with double underscore if any ( path . startswith ( \"__\" ) for path in path_dir_list ): continue # Ignore hidden folders and first layer. the root repo is always dot # Keep double dot. It means going back to the parent folder if any ( path . startswith ( \".\" ) and not path . startswith ( \"..\" ) for path in path_dir_list [ 1 :] ): continue for filename in filenames : # Ignore special files if filename . startswith ( \"__\" ) or filename . startswith ( \".\" ): continue # Combine the path with file name to get a complete path complete_actual_path = os . path . join ( dirpath , filename ) + os . path . sep for target in corrected_paths : if target in complete_actual_path : polished_paths = complete_actual_path . replace ( f \" { relative_run_path }{ os . path . sep } \" , \"\" ) targeted_paths . append ( polished_paths ) # If any of the user inputted file does not exist in any directory, # throw an exception indicating failure if not targeted_paths : typer . secho ( \"FAILURE: None of the user-provided file paths are\" \" found in the provided directory and the 'gatorgrade.yml' is NOT generated\" , fg = typer . colors . RED , err = True , ) raise typer . Exit ( 1 ) # If some of the files are found and some are not found, # output a warning message saying which files were not found targeted_paths_string = \" \" . join ( targeted_paths ) for key in target_path_list : if key not in targeted_paths_string : typer . secho ( f \"WARNING \\u26A0 : ' { key } ' file path is not FOUND!\" f \" \\n All file paths except ' { key } ' are successfully\" \" generated in the 'gatorgrade.yml' file\" , fg = typer . colors . YELLOW , ) return targeted_paths # If all the files exist in the root directory, print out a success message if targeted_paths : typer . secho ( \"SUCCESS \\U0001F525 : All the file paths were\" \" successfully generated in the 'gatorgrade.yml' file!\" , fg = typer . colors . GREEN , ) return targeted_paths generate_config ( target_path_list , search_root = '.' ) Generate config by creating targeted paths in a list of strings, then create a YAML file. Source code in gatorgrade/generate/generate.py 136 137 138 139 def generate_config ( target_path_list : List [ str ], search_root : str = \".\" ): \"\"\"Generate config by creating targeted paths in a list of strings, then create a YAML file.\"\"\" targeted_paths = create_targeted_paths_list ( target_path_list , search_root ) write_yaml_of_paths_list ( targeted_paths , search_root ) input_correct ( initial_path_list , run_path ) Correct user-written paths. Source code in gatorgrade/generate/generate.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def input_correct ( initial_path_list : List [ str ], run_path : str ) -> Dict : \"\"\"Correct user-written paths.\"\"\" # Recognize the paths users provide are the concise versions. # Unify the ending format to avoid different users' different input corrected_path = [] # Run_path unify if run_path . endswith ( os . path . sep ) is False : run_path += os . path . sep for path in initial_path_list : # Combine the running path with the target path # To make sure the target path starts from the running directory path = run_path + path # Treat the last unit of the path as a concise name unit if path . endswith ( os . path . sep ) is False : path += os . path . sep corrected_path . append ( path ) # Convert list to dictionary for faster iteration return dict . fromkeys ( corrected_path , \"\" ) write_yaml_of_paths_list ( path_names , search_root ) Write YAML file to create gatorgrade file and set default messages. Source code in gatorgrade/generate/generate.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def write_yaml_of_paths_list ( path_names : List [ str ], search_root : str ): # expected input: A path list \"\"\"Write YAML file to create gatorgrade file and set default messages.\"\"\" files_list = [] # Create an empty list to store dictionaries for file_path in path_names : # Iterate through items in path_names if file_path . endswith ( os . path . sep ): file_path = file_path [ 0 : - 1 ] # Convert file separators to '/' file_path_fixed = file_path . replace ( os . path . sep , \"/\" ) # Make file_path easier to read by removing unnecessary characters file_path_dict = { # Dictionary to store the file paths file_path_fixed : [ # List which stores strings which will be in gatorgrade.yml file { \"description\" : f \"Complete all TODOs in { file_path_fixed } \" , \"check\" : \"MatchFileFragment\" , \"options\" : { \"fragment\" : \"TODO\" , \"count\" : 0 , \"exact\" : True }, } ] } # Append files_list with the values stored inside file_path_dict files_list . append ( file_path_dict ) with open ( f \" { search_root }{ os . path . sep } gatorgrade.yml\" , \"w\" , encoding = \"utf-8\" ) as file : # Write a new YAML file named gatorgrade yaml . dump ( files_list , file , sort_keys = False )","title":"generate"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.create_targeted_paths_list","text":"Generate a list of targeted paths by walking the paths. Source code in gatorgrade/generate/generate.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def create_targeted_paths_list ( target_path_list : List [ str ], relative_run_path : str = \".\" ) -> List [ str ]: \"\"\"Generate a list of targeted paths by walking the paths.\"\"\" targeted_paths = [] corrected_paths = input_correct ( target_path_list , relative_run_path ) # Go through the root repo, the sub dictionaries and files # The os.walk will only scan the paths # So the empty folders containing nothing won't be gone through for dirpath , _ , filenames in os . walk ( relative_run_path ): # Split path string into multiple layers of directories path_dir_list = dirpath . split ( os . path . sep ) # Ignore folder starting with double underscore if any ( path . startswith ( \"__\" ) for path in path_dir_list ): continue # Ignore hidden folders and first layer. the root repo is always dot # Keep double dot. It means going back to the parent folder if any ( path . startswith ( \".\" ) and not path . startswith ( \"..\" ) for path in path_dir_list [ 1 :] ): continue for filename in filenames : # Ignore special files if filename . startswith ( \"__\" ) or filename . startswith ( \".\" ): continue # Combine the path with file name to get a complete path complete_actual_path = os . path . join ( dirpath , filename ) + os . path . sep for target in corrected_paths : if target in complete_actual_path : polished_paths = complete_actual_path . replace ( f \" { relative_run_path }{ os . path . sep } \" , \"\" ) targeted_paths . append ( polished_paths ) # If any of the user inputted file does not exist in any directory, # throw an exception indicating failure if not targeted_paths : typer . secho ( \"FAILURE: None of the user-provided file paths are\" \" found in the provided directory and the 'gatorgrade.yml' is NOT generated\" , fg = typer . colors . RED , err = True , ) raise typer . Exit ( 1 ) # If some of the files are found and some are not found, # output a warning message saying which files were not found targeted_paths_string = \" \" . join ( targeted_paths ) for key in target_path_list : if key not in targeted_paths_string : typer . secho ( f \"WARNING \\u26A0 : ' { key } ' file path is not FOUND!\" f \" \\n All file paths except ' { key } ' are successfully\" \" generated in the 'gatorgrade.yml' file\" , fg = typer . colors . YELLOW , ) return targeted_paths # If all the files exist in the root directory, print out a success message if targeted_paths : typer . secho ( \"SUCCESS \\U0001F525 : All the file paths were\" \" successfully generated in the 'gatorgrade.yml' file!\" , fg = typer . colors . GREEN , ) return targeted_paths","title":"create_targeted_paths_list()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.generate_config","text":"Generate config by creating targeted paths in a list of strings, then create a YAML file. Source code in gatorgrade/generate/generate.py 136 137 138 139 def generate_config ( target_path_list : List [ str ], search_root : str = \".\" ): \"\"\"Generate config by creating targeted paths in a list of strings, then create a YAML file.\"\"\" targeted_paths = create_targeted_paths_list ( target_path_list , search_root ) write_yaml_of_paths_list ( targeted_paths , search_root )","title":"generate_config()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.input_correct","text":"Correct user-written paths. Source code in gatorgrade/generate/generate.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def input_correct ( initial_path_list : List [ str ], run_path : str ) -> Dict : \"\"\"Correct user-written paths.\"\"\" # Recognize the paths users provide are the concise versions. # Unify the ending format to avoid different users' different input corrected_path = [] # Run_path unify if run_path . endswith ( os . path . sep ) is False : run_path += os . path . sep for path in initial_path_list : # Combine the running path with the target path # To make sure the target path starts from the running directory path = run_path + path # Treat the last unit of the path as a concise name unit if path . endswith ( os . path . sep ) is False : path += os . path . sep corrected_path . append ( path ) # Convert list to dictionary for faster iteration return dict . fromkeys ( corrected_path , \"\" )","title":"input_correct()"},{"location":"reference/generate/generate/#gatorgrade.generate.generate.write_yaml_of_paths_list","text":"Write YAML file to create gatorgrade file and set default messages. Source code in gatorgrade/generate/generate.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def write_yaml_of_paths_list ( path_names : List [ str ], search_root : str ): # expected input: A path list \"\"\"Write YAML file to create gatorgrade file and set default messages.\"\"\" files_list = [] # Create an empty list to store dictionaries for file_path in path_names : # Iterate through items in path_names if file_path . endswith ( os . path . sep ): file_path = file_path [ 0 : - 1 ] # Convert file separators to '/' file_path_fixed = file_path . replace ( os . path . sep , \"/\" ) # Make file_path easier to read by removing unnecessary characters file_path_dict = { # Dictionary to store the file paths file_path_fixed : [ # List which stores strings which will be in gatorgrade.yml file { \"description\" : f \"Complete all TODOs in { file_path_fixed } \" , \"check\" : \"MatchFileFragment\" , \"options\" : { \"fragment\" : \"TODO\" , \"count\" : 0 , \"exact\" : True }, } ] } # Append files_list with the values stored inside file_path_dict files_list . append ( file_path_dict ) with open ( f \" { search_root }{ os . path . sep } gatorgrade.yml\" , \"w\" , encoding = \"utf-8\" ) as file : # Write a new YAML file named gatorgrade yaml . dump ( files_list , file , sort_keys = False )","title":"write_yaml_of_paths_list()"},{"location":"reference/input/checks/","text":"Define check classes. GatorGraderCheck Represent a GatorGrader check. Source code in gatorgrade/input/checks.py 23 24 25 26 27 28 29 30 31 32 33 34 class GatorGraderCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a GatorGrader check.\"\"\" def __init__ ( self , gg_args : List [ str ], json_info ): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. json_info: The all-encompassing check information to include in json output. \"\"\" self . gg_args = gg_args self . json_info = json_info __init__ ( gg_args , json_info ) Construct a GatorGraderCheck. Parameters: Name Type Description Default gg_args List [ str ] The list of arguments to pass to GatorGrader. required json_info The all-encompassing check information to include in json output. required Source code in gatorgrade/input/checks.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , gg_args : List [ str ], json_info ): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. json_info: The all-encompassing check information to include in json output. \"\"\" self . gg_args = gg_args self . json_info = json_info ShellCheck Represent a shell check. Source code in gatorgrade/input/checks.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ShellCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a shell check.\"\"\" def __init__ ( self , command : str , description : str = None , json_info = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. json_info: The all-encompassing check information to include in json output. If none is given, command is used \"\"\" self . command = command self . description = description if description is not None else command self . json_info = json_info __init__ ( command , description = None , json_info = None ) Construct a ShellCheck. Parameters: Name Type Description Default command str The command to run in a shell. required description str The description to use in output. If no description is given, the command is used as the description. None json_info The all-encompassing check information to include in json output. If none is given, command is used None Source code in gatorgrade/input/checks.py 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , command : str , description : str = None , json_info = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. json_info: The all-encompassing check information to include in json output. If none is given, command is used \"\"\" self . command = command self . description = description if description is not None else command self . json_info = json_info","title":"checks"},{"location":"reference/input/checks/#gatorgrade.input.checks.GatorGraderCheck","text":"Represent a GatorGrader check. Source code in gatorgrade/input/checks.py 23 24 25 26 27 28 29 30 31 32 33 34 class GatorGraderCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a GatorGrader check.\"\"\" def __init__ ( self , gg_args : List [ str ], json_info ): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. json_info: The all-encompassing check information to include in json output. \"\"\" self . gg_args = gg_args self . json_info = json_info","title":"GatorGraderCheck"},{"location":"reference/input/checks/#gatorgrade.input.checks.GatorGraderCheck.__init__","text":"Construct a GatorGraderCheck. Parameters: Name Type Description Default gg_args List [ str ] The list of arguments to pass to GatorGrader. required json_info The all-encompassing check information to include in json output. required Source code in gatorgrade/input/checks.py 26 27 28 29 30 31 32 33 34 def __init__ ( self , gg_args : List [ str ], json_info ): \"\"\"Construct a GatorGraderCheck. Args: gg_args: The list of arguments to pass to GatorGrader. json_info: The all-encompassing check information to include in json output. \"\"\" self . gg_args = gg_args self . json_info = json_info","title":"__init__()"},{"location":"reference/input/checks/#gatorgrade.input.checks.ShellCheck","text":"Represent a shell check. Source code in gatorgrade/input/checks.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ShellCheck : # pylint: disable=too-few-public-methods \"\"\"Represent a shell check.\"\"\" def __init__ ( self , command : str , description : str = None , json_info = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. json_info: The all-encompassing check information to include in json output. If none is given, command is used \"\"\" self . command = command self . description = description if description is not None else command self . json_info = json_info","title":"ShellCheck"},{"location":"reference/input/checks/#gatorgrade.input.checks.ShellCheck.__init__","text":"Construct a ShellCheck. Parameters: Name Type Description Default command str The command to run in a shell. required description str The description to use in output. If no description is given, the command is used as the description. None json_info The all-encompassing check information to include in json output. If none is given, command is used None Source code in gatorgrade/input/checks.py 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , command : str , description : str = None , json_info = None ): \"\"\"Construct a ShellCheck. Args: command: The command to run in a shell. description: The description to use in output. If no description is given, the command is used as the description. json_info: The all-encompassing check information to include in json output. If none is given, command is used \"\"\" self . command = command self . description = description if description is not None else command self . json_info = json_info","title":"__init__()"},{"location":"reference/input/command_line_generator/","text":"Generates a dictionary of shell and gator grader command options from a list of dict checks. generate_checks ( check_data_list ) Generate a list of checks based on check data from the configuration file. Parameters: Name Type Description Default check_data_list List [ CheckData ] A list of CheckData that each represent a check from the configuration file. required Returns: Type Description List [ Union [ ShellCheck , GatorGraderCheck ]] A list of ShellChecks and GatorGraderChecks. Source code in gatorgrade/input/command_line_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def generate_checks ( check_data_list : List [ CheckData ], ) -> List [ Union [ ShellCheck , GatorGraderCheck ]]: \"\"\"Generate a list of checks based on check data from the configuration file. Args: check_data_list: A list of CheckData that each represent a check from the configuration file. Returns: A list of ShellChecks and GatorGraderChecks. \"\"\" checks = [] for check_data in check_data_list : # If the check has a `command` key, then it is a shell check if \"command\" in check_data . check : checks . append ( ShellCheck ( command = check_data . check . get ( \"command\" ), description = check_data . check . get ( \"description\" ), json_info = check_data . check , ) ) # Otherwise, it is a GatorGrader check else : gg_args = [] # Add description option if in data description = check_data . check . get ( \"description\" ) if description is not None : gg_args . extend ([ \"--description\" , str ( description )]) # Always add name of check, which should be in data gg_args . append ( str ( check_data . check . get ( \"check\" ))) # Add any additional options options = check_data . check . get ( \"options\" ) if options is not None : for option in options : # If option should be a flag (i.e. its value is the `True` boolean), # add only the option without a value option_value = options [ option ] if isinstance ( option_value , bool ): if option_value : gg_args . append ( f \"-- { option } \" ) # Otherwise, add both the option and its value else : gg_args . extend ([ f \"-- { option } \" , str ( option_value )]) # Add directory and file if file context in data if check_data . file_context is not None : # Get the file and directory using os dirname , filename = os . path . split ( check_data . file_context ) if dirname == \"\" : dirname = \".\" gg_args . extend ([ \"--directory\" , dirname , \"--file\" , filename ]) checks . append ( GatorGraderCheck ( gg_args = gg_args , json_info = check_data . check )) return checks","title":"command_line_generator"},{"location":"reference/input/command_line_generator/#gatorgrade.input.command_line_generator.generate_checks","text":"Generate a list of checks based on check data from the configuration file. Parameters: Name Type Description Default check_data_list List [ CheckData ] A list of CheckData that each represent a check from the configuration file. required Returns: Type Description List [ Union [ ShellCheck , GatorGraderCheck ]] A list of ShellChecks and GatorGraderChecks. Source code in gatorgrade/input/command_line_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def generate_checks ( check_data_list : List [ CheckData ], ) -> List [ Union [ ShellCheck , GatorGraderCheck ]]: \"\"\"Generate a list of checks based on check data from the configuration file. Args: check_data_list: A list of CheckData that each represent a check from the configuration file. Returns: A list of ShellChecks and GatorGraderChecks. \"\"\" checks = [] for check_data in check_data_list : # If the check has a `command` key, then it is a shell check if \"command\" in check_data . check : checks . append ( ShellCheck ( command = check_data . check . get ( \"command\" ), description = check_data . check . get ( \"description\" ), json_info = check_data . check , ) ) # Otherwise, it is a GatorGrader check else : gg_args = [] # Add description option if in data description = check_data . check . get ( \"description\" ) if description is not None : gg_args . extend ([ \"--description\" , str ( description )]) # Always add name of check, which should be in data gg_args . append ( str ( check_data . check . get ( \"check\" ))) # Add any additional options options = check_data . check . get ( \"options\" ) if options is not None : for option in options : # If option should be a flag (i.e. its value is the `True` boolean), # add only the option without a value option_value = options [ option ] if isinstance ( option_value , bool ): if option_value : gg_args . append ( f \"-- { option } \" ) # Otherwise, add both the option and its value else : gg_args . extend ([ f \"-- { option } \" , str ( option_value )]) # Add directory and file if file context in data if check_data . file_context is not None : # Get the file and directory using os dirname , filename = os . path . split ( check_data . file_context ) if dirname == \"\" : dirname = \".\" gg_args . extend ([ \"--directory\" , dirname , \"--file\" , filename ]) checks . append ( GatorGraderCheck ( gg_args = gg_args , json_info = check_data . check )) return checks","title":"generate_checks()"},{"location":"reference/input/in_file_path/","text":"Generates a list of commands to be run through gatorgrader. add_checks_to_list ( path , data_list , reformatted_data ) Recursively loop through the data and add checks that are found to the reformatted list. Source code in gatorgrade/input/in_file_path.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def add_checks_to_list ( path , data_list , reformatted_data ) -> List [ CheckData ]: \"\"\"Recursively loop through the data and add checks that are found to the reformatted list.\"\"\" current_path = path # Saves the current path to keep track of the location for ddict in data_list : for item in ddict : if isinstance ( ddict [ item ], list ): # Checks if the current dictionary has another list as its value if not path : path = item else : path = f \" { path } / { item } \" add_checks_to_list ( path , ddict [ item ], reformatted_data ) # Runs this same function on the list inside of a dictionary path = current_path else : # Adds the current check to the reformatted data list reformatted_data . append ( CheckData ( file_context = path , check = ddict )) break parse_yaml_file ( file_path ) Parse a YAML file and return its contents as a list of dictionaries. Source code in gatorgrade/input/in_file_path.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def parse_yaml_file ( file_path : Path ) -> List [ Any ]: \"\"\"Parse a YAML file and return its contents as a list of dictionaries.\"\"\" # confirm that the file exists before attempting to read from it if file_path . exists (): # read the contents of the specified file using the default # encoding and then parse that file using the yaml package with open ( file_path , encoding = DEFAULT_ENCODING ) as file : # after parsing with the yaml module, return a list # of all of the contents specified in the file data = yaml . load_all ( file , Loader = yaml . FullLoader ) return list ( data ) # some aspect of the file does not exist # (i.e., wrong file or wrong directory) # and thus parsing with YAML is not possible; # return a blank list that calling function handles return [] reformat_yaml_data ( data ) Reformat the raw data from a YAML file into a list of tuples. Source code in gatorgrade/input/in_file_path.py 39 40 41 42 43 44 45 46 def reformat_yaml_data ( data ): \"\"\"Reformat the raw data from a YAML file into a list of tuples.\"\"\" reformatted_data = [] if len ( data ) == 2 : setup_commands = data . pop ( 0 ) # Removes the setup commands run_setup ( setup_commands ) add_checks_to_list ( None , data [ 0 ], reformatted_data ) return reformatted_data","title":"in_file_path"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.add_checks_to_list","text":"Recursively loop through the data and add checks that are found to the reformatted list. Source code in gatorgrade/input/in_file_path.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def add_checks_to_list ( path , data_list , reformatted_data ) -> List [ CheckData ]: \"\"\"Recursively loop through the data and add checks that are found to the reformatted list.\"\"\" current_path = path # Saves the current path to keep track of the location for ddict in data_list : for item in ddict : if isinstance ( ddict [ item ], list ): # Checks if the current dictionary has another list as its value if not path : path = item else : path = f \" { path } / { item } \" add_checks_to_list ( path , ddict [ item ], reformatted_data ) # Runs this same function on the list inside of a dictionary path = current_path else : # Adds the current check to the reformatted data list reformatted_data . append ( CheckData ( file_context = path , check = ddict )) break","title":"add_checks_to_list()"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.parse_yaml_file","text":"Parse a YAML file and return its contents as a list of dictionaries. Source code in gatorgrade/input/in_file_path.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def parse_yaml_file ( file_path : Path ) -> List [ Any ]: \"\"\"Parse a YAML file and return its contents as a list of dictionaries.\"\"\" # confirm that the file exists before attempting to read from it if file_path . exists (): # read the contents of the specified file using the default # encoding and then parse that file using the yaml package with open ( file_path , encoding = DEFAULT_ENCODING ) as file : # after parsing with the yaml module, return a list # of all of the contents specified in the file data = yaml . load_all ( file , Loader = yaml . FullLoader ) return list ( data ) # some aspect of the file does not exist # (i.e., wrong file or wrong directory) # and thus parsing with YAML is not possible; # return a blank list that calling function handles return []","title":"parse_yaml_file()"},{"location":"reference/input/in_file_path/#gatorgrade.input.in_file_path.reformat_yaml_data","text":"Reformat the raw data from a YAML file into a list of tuples. Source code in gatorgrade/input/in_file_path.py 39 40 41 42 43 44 45 46 def reformat_yaml_data ( data ): \"\"\"Reformat the raw data from a YAML file into a list of tuples.\"\"\" reformatted_data = [] if len ( data ) == 2 : setup_commands = data . pop ( 0 ) # Removes the setup commands run_setup ( setup_commands ) add_checks_to_list ( None , data [ 0 ], reformatted_data ) return reformatted_data","title":"reformat_yaml_data()"},{"location":"reference/input/parse_config/","text":"Returns the list of commands to be run through gatorgrader. parse_config ( file ) Parse the input yaml file and generate specified checks. Parameters: Name Type Description Default file Path Yaml file containing gatorgrade and shell command checks required Returns: Type Description Returns a dictionary that specifies shell commands and gatorgrade commands Source code in gatorgrade/input/parse_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def parse_config ( file : Path ): \"\"\"Parse the input yaml file and generate specified checks. Args: file: Yaml file containing gatorgrade and shell command checks Returns: Returns a dictionary that specifies shell commands and gatorgrade commands \"\"\" # parse the YAML file using parse_yaml_file provided by gatorgrade parsed_yaml_file = parse_yaml_file ( file ) # the parsed YAML file contains some contents in a list and thus # the tool should generate a GatorGrader check for each element in list if len ( parsed_yaml_file ) > 0 : # after reformatting the parse YAML file, # use it to generate all of the checks; # these will be valid checks that are now # ready for execution with this tool parse_con = generate_checks ( reformat_yaml_data ( parsed_yaml_file )) return parse_con # return an empty list because of the fact that the # parsing process did not return a list with content; # allow the calling function to handle the empty list return []","title":"parse_config"},{"location":"reference/input/parse_config/#gatorgrade.input.parse_config.parse_config","text":"Parse the input yaml file and generate specified checks. Parameters: Name Type Description Default file Path Yaml file containing gatorgrade and shell command checks required Returns: Type Description Returns a dictionary that specifies shell commands and gatorgrade commands Source code in gatorgrade/input/parse_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def parse_config ( file : Path ): \"\"\"Parse the input yaml file and generate specified checks. Args: file: Yaml file containing gatorgrade and shell command checks Returns: Returns a dictionary that specifies shell commands and gatorgrade commands \"\"\" # parse the YAML file using parse_yaml_file provided by gatorgrade parsed_yaml_file = parse_yaml_file ( file ) # the parsed YAML file contains some contents in a list and thus # the tool should generate a GatorGrader check for each element in list if len ( parsed_yaml_file ) > 0 : # after reformatting the parse YAML file, # use it to generate all of the checks; # these will be valid checks that are now # ready for execution with this tool parse_con = generate_checks ( reformat_yaml_data ( parsed_yaml_file )) return parse_con # return an empty list because of the fact that the # parsing process did not return a list with content; # allow the calling function to handle the empty list return []","title":"parse_config()"},{"location":"reference/input/set_up_shell/","text":"Set-up the shell commands. run_setup ( front_matter ) Run the shell set up commands and exit the program if a command fails. Parameters: Name Type Description Default front_matter A dictionary whose 'setup' key contains the set up commands required Source code in gatorgrade/input/set_up_shell.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def run_setup ( front_matter ): \"\"\"Run the shell set up commands and exit the program if a command fails. Args: front_matter: A dictionary whose 'setup' key contains the set up commands as a multi-line string. \"\"\" # If setup exists in the front matter setup = front_matter . get ( \"setup\" ) if setup : typer . echo ( \"Running set up commands...\" ) for line in setup . splitlines (): # Trims the white space command = line . strip () # Executes the command proc = subprocess . run ( command , shell = True , check = False , timeout = 300 ) # If the exit code tells it was unsuccessful and did not return 0 if proc . returncode != 0 : typer . secho ( f 'The set up command \" { command } \" failed. \\ Exiting GatorGrade.' , err = True , fg = typer . colors . RED , ) # If a set up command failed, exit the execution # because environment was not set up correctly. raise typer . Exit ( 1 ) typer . echo ( \"Finished! \\n \" )","title":"set_up_shell"},{"location":"reference/input/set_up_shell/#gatorgrade.input.set_up_shell.run_setup","text":"Run the shell set up commands and exit the program if a command fails. Parameters: Name Type Description Default front_matter A dictionary whose 'setup' key contains the set up commands required Source code in gatorgrade/input/set_up_shell.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def run_setup ( front_matter ): \"\"\"Run the shell set up commands and exit the program if a command fails. Args: front_matter: A dictionary whose 'setup' key contains the set up commands as a multi-line string. \"\"\" # If setup exists in the front matter setup = front_matter . get ( \"setup\" ) if setup : typer . echo ( \"Running set up commands...\" ) for line in setup . splitlines (): # Trims the white space command = line . strip () # Executes the command proc = subprocess . run ( command , shell = True , check = False , timeout = 300 ) # If the exit code tells it was unsuccessful and did not return 0 if proc . returncode != 0 : typer . secho ( f 'The set up command \" { command } \" failed. \\ Exiting GatorGrade.' , err = True , fg = typer . colors . RED , ) # If a set up command failed, exit the execution # because environment was not set up correctly. raise typer . Exit ( 1 ) typer . echo ( \"Finished! \\n \" )","title":"run_setup()"},{"location":"reference/output/check_result/","text":"Define check result class. CheckResult Represent the result of running a check. Source code in gatorgrade/output/check_result.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class CheckResult : # pylint: disable=too-few-public-methods \"\"\"Represent the result of running a check.\"\"\" def __init__ ( self , passed : bool , description : str , json_info , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. json_info: the overall information to be included in json output diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . json_info = json_info self . diagnostic = diagnostic def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\u2713\" if self . passed else \"\u2715\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message += f \" \\n [yellow] \u2192 { self . diagnostic } \" return message def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) rich . print ( message ) __init__ ( passed , description , json_info , diagnostic = 'No diagnostic message available' ) Construct a CheckResult. Parameters: Name Type Description Default passed bool The passed or failed status of the check result. If true, indicates that the check has passed. required description str The description to use in output. required json_info the overall information to be included in json output required diagnostic str The message to use in output if the check has failed. 'No diagnostic message available' Source code in gatorgrade/output/check_result.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def __init__ ( self , passed : bool , description : str , json_info , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. json_info: the overall information to be included in json output diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . json_info = json_info self . diagnostic = diagnostic __str__ ( show_diagnostic = False ) Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 46 47 48 49 50 51 52 53 54 55 56 def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message display_result ( show_diagnostic = False ) Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\u2713\" if self . passed else \"\u2715\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message += f \" \\n [yellow] \u2192 { self . diagnostic } \" return message print ( show_diagnostic = False ) Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 58 59 60 61 62 63 64 65 66 67 68 def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) rich . print ( message )","title":"check_result"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult","text":"Represent the result of running a check. Source code in gatorgrade/output/check_result.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class CheckResult : # pylint: disable=too-few-public-methods \"\"\"Represent the result of running a check.\"\"\" def __init__ ( self , passed : bool , description : str , json_info , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. json_info: the overall information to be included in json output diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . json_info = json_info self . diagnostic = diagnostic def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\u2713\" if self . passed else \"\u2715\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message += f \" \\n [yellow] \u2192 { self . diagnostic } \" return message def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) rich . print ( message )","title":"CheckResult"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.__init__","text":"Construct a CheckResult. Parameters: Name Type Description Default passed bool The passed or failed status of the check result. If true, indicates that the check has passed. required description str The description to use in output. required json_info the overall information to be included in json output required diagnostic str The message to use in output if the check has failed. 'No diagnostic message available' Source code in gatorgrade/output/check_result.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def __init__ ( self , passed : bool , description : str , json_info , diagnostic : str = \"No diagnostic message available\" , ): \"\"\"Construct a CheckResult. Args: passed: The passed or failed status of the check result. If true, indicates that the check has passed. description: The description to use in output. json_info: the overall information to be included in json output diagnostic: The message to use in output if the check has failed. \"\"\" self . passed = passed self . description = description self . json_info = json_info self . diagnostic = diagnostic","title":"__init__()"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.__str__","text":"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 46 47 48 49 50 51 52 53 54 55 56 def __str__ ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) return message","title":"__str__()"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.display_result","text":"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def display_result ( self , show_diagnostic : bool = False ) -> str : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" icon = \"\u2713\" if self . passed else \"\u2715\" icon_color = \"green\" if self . passed else \"red\" message = f \"[ { icon_color } ] { icon } [/] { self . description } \" if not self . passed and show_diagnostic : message += f \" \\n [yellow] \u2192 { self . diagnostic } \" return message","title":"display_result()"},{"location":"reference/output/check_result/#gatorgrade.output.check_result.CheckResult.print","text":"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Parameters: Name Type Description Default show_diagnostic bool If true, show the diagnostic message if the check has failed. Defaults to false. False Source code in gatorgrade/output/check_result.py 58 59 60 61 62 63 64 65 66 67 68 def print ( self , show_diagnostic : bool = False ) -> None : \"\"\"Print check's passed or failed status, description, and, optionally, diagnostic message. If no diagnostic message is available, then the output will say so. Args: show_diagnostic: If true, show the diagnostic message if the check has failed. Defaults to false. \"\"\" message = self . display_result ( show_diagnostic ) rich . print ( message )","title":"print()"},{"location":"reference/output/output/","text":"Run checks and display whether each has passed or failed. _run_gg_check ( check ) Run a GatorGrader check. Parameters: Name Type Description Default check GatorGraderCheck The GatorGrader check to run. required Returns: Type Description CheckResult The result of running the GatorGrader check as a CheckResult. Source code in gatorgrade/output/output.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def _run_gg_check ( check : GatorGraderCheck ) -> CheckResult : \"\"\"Run a GatorGrader check. Args: check: The GatorGrader check to run. Returns: The result of running the GatorGrader check as a CheckResult. \"\"\" try : result = gator . grader ( check . gg_args ) passed = result [ 1 ] description = result [ 0 ] diagnostic = result [ 2 ] # If arguments are formatted incorrectly, catch the exception and # return it as the diagnostic message # Disable pylint to catch any type of exception thrown by GatorGrader except Exception as command_exception : # pylint: disable=W0703 passed = False description = f 'Invalid GatorGrader check: \" { \" \" . join ( check . gg_args ) } \"' diagnostic = f '\" { command_exception . __class__ } \" thrown by GatorGrader' return CheckResult ( passed = passed , description = description , json_info = check . json_info , diagnostic = diagnostic , ) _run_shell_check ( check ) Run a shell check. Parameters: Name Type Description Default check ShellCheck The shell check to run. required Returns: Type Description CheckResult The result of running the shell check as a CheckResult. Source code in gatorgrade/output/output.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def _run_shell_check ( check : ShellCheck ) -> CheckResult : \"\"\"Run a shell check. Args: check: The shell check to run. Returns: The result of running the shell check as a CheckResult. \"\"\" result = subprocess . run ( check . command , shell = True , check = False , timeout = 300 , stdout = subprocess . PIPE , # Redirect STDERR to STDOUT so STDOUT and STDERR can be captured # together as diagnostic stderr = subprocess . STDOUT , ) passed = result . returncode == 0 # Add spaces after each newline to indent all lines of diagnostic diagnostic = ( \"\" if passed else result . stdout . decode () . strip () . replace ( \" \\n \" , \" \\n \" ) ) return CheckResult ( passed = passed , description = check . description , json_info = check . json_info , diagnostic = diagnostic , ) configure_report ( report_params , report_output_data_json ) Put together the contents of the report depending on the inputs of the user. Parameters: Name Type Description Default report_params Tuple [ str , str , str ] The details of what the user wants the report to look like report_params[0]: file or env report_params[1]: json or md report_params[2]: name of the file or env required report_output_data the json dictionary that will be used or converted to md required Source code in gatorgrade/output/output.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def configure_report ( report_params : Tuple [ str , str , str ], report_output_data_json : dict ): \"\"\"Put together the contents of the report depending on the inputs of the user. Args: report_params: The details of what the user wants the report to look like report_params[0]: file or env report_params[1]: json or md report_params[2]: name of the file or env report_output_data: the json dictionary that will be used or converted to md \"\"\" report_format = report_params [ 0 ] report_type = report_params [ 1 ] report_name = report_params [ 2 ] if report_type not in ( \"json\" , \"md\" ): raise ValueError ( \" \\n [red]The second argument of report has to be 'md' or 'json' \" ) # if the user wants markdown, get markdown content based on json if report_type == \"md\" : report_output_data_md = create_markdown_report_file ( report_output_data_json ) # if the user wants the data stored in a file: if report_format == \"file\" : if report_type == \"md\" : write_json_or_md_file ( report_name , report_type , report_output_data_md ) else : write_json_or_md_file ( report_name , report_type , report_output_data_json ) elif report_format == \"env\" : if report_name == \"GITHUB_STEP_SUMMARY\" : env_file = os . getenv ( \"GITHUB_STEP_SUMMARY\" ) if report_type == \"md\" : write_json_or_md_file ( env_file , report_type , report_output_data_md ) else : write_json_or_md_file ( env_file , report_type , report_output_data_json ) # Add json report into the GITHUB_ENV environment variable for data collection purpose env_file = os . getenv ( \"GITHUB_ENV\" ) with open ( env_file , \"a\" ) as myfile : myfile . write ( f \"JSON_REPORT= { report_output_data_json } \" ) # Add env else : raise ValueError ( \" \\n [red]The first argument of report has to be 'env' or 'file' \" ) create_markdown_report_file ( json ) Create a markdown file using the created json to use in github actions summary, among other places. Parameters: Name Type Description Default json dict a dictionary containing the json that should be converted to markdown required Source code in gatorgrade/output/output.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def create_markdown_report_file ( json : dict ) -> str : \"\"\"Create a markdown file using the created json to use in github actions summary, among other places. Args: json: a dictionary containing the json that should be converted to markdown \"\"\" markdown_contents = \"\" passing_checks = [] failing_checks = [] num_checks = len ( json . get ( \"checks\" )) # write the total, amt correct and percentage score to md file markdown_contents += f \"# Gatorgrade Insights \\n\\n **Project Name:** { Path . cwd () . name } \\n **Amount Correct:** { ( json . get ( 'amount_correct' )) } / { num_checks } ( { ( json . get ( 'percentage_score' )) } %) \\n \" # split checks into passing and not passing for check in json . get ( \"checks\" ): # if the check is passing if check [ \"status\" ] == True : passing_checks . append ( check ) # if the check is failing else : failing_checks . append ( check ) # give short info about passing checks markdown_contents += \" \\n ## Passing Checks \\n \" for check in passing_checks : if \"description\" in check : markdown_contents += f \" \\n - [x] { check [ 'description' ] } \" else : markdown_contents += f \" \\n - [x] { check [ 'check' ] } \" # give extended information about failing checks markdown_contents += \" \\n\\n ## Failing Checks \\n \" # for each failing check, print out all related information for check in failing_checks : # for each key val pair in the check dictionary if \"description\" in check : markdown_contents += f \" \\n - [ ] { check [ 'description' ] } \" else : markdown_contents += f \" \\n - [ ] { check [ 'check' ] } \" if \"options\" in check : for i in check . get ( \"options\" ): if \"command\" == i : val = check [ \"options\" ][ \"command\" ] markdown_contents += f \" \\n\\t - **command** { val } \" if \"fragment\" == i : val = check [ \"options\" ][ \"fragment\" ] markdown_contents += f \" \\n\\t - **fragment:** { val } \" if \"tag\" == i : val = check [ \"options\" ][ \"tag\" ] markdown_contents += f \" \\n\\t - **tag:** { val } \" if \"count\" == i : val = check [ \"options\" ][ \"count\" ] markdown_contents += f \" \\n\\t - **count:** { val } \" if \"directory\" == i : val = check [ \"options\" ][ \"directory\" ] markdown_contents += f \" \\n\\t - **directory:** { val } \" if \"file\" == i : val = check [ \"options\" ][ \"file\" ] markdown_contents += f \" \\n\\t - **file:** { val } \" elif \"command\" in check : val = check [ \"command\" ] markdown_contents += f \" \\n\\t - **command:** { val } \" if \"diagnostic\" in check : markdown_contents += f \" \\n\\t - **diagnostic:** { check [ 'diagnostic' ] } \" markdown_contents += \" \\n \" return markdown_contents create_report_json ( passed_count , checkResults , percent_passed ) Take checks and put them into json format in a dictionary. Parameters: Name Type Description Default passed_count the number of checks that passed required check_information the basic information about checks and their params required checkResults List [ CheckResult ] the list of check results that will be put in json required percent_passed the percentage of checks that passed required Source code in gatorgrade/output/output.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def create_report_json ( passed_count , checkResults : List [ CheckResult ], percent_passed , ) -> dict : \"\"\"Take checks and put them into json format in a dictionary. Args: passed_count: the number of checks that passed check_information: the basic information about checks and their params checkResults: the list of check results that will be put in json percent_passed: the percentage of checks that passed \"\"\" # create list to hold the key values for the dictionary that # will be converted into json overall_key_list = [ \"amount_correct\" , \"percentage_score\" , \"checks\" ] checks_list = [] overall_dict = {} # for each check: for i in range ( len ( checkResults )): # grab all of the information in it and add it to the checks list results_json = checkResults [ i ] . json_info results_json [ \"status\" ] = checkResults [ i ] . passed if not checkResults [ i ] . passed : results_json [ \"diagnostic\" ] = checkResults [ i ] . diagnostic checks_list . append ( results_json ) # create the dictionary for all of the check information overall_dict = dict ( zip ( overall_key_list , [ passed_count , percent_passed , checks_list ]) ) return overall_dict print_with_border ( text , rich_color ) Print text with a border. Parameters: Name Type Description Default text str Text to print required rich_color str Color of text to print required Source code in gatorgrade/output/output.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def print_with_border ( text : str , rich_color : str ): \"\"\"Print text with a border. Args: text: Text to print rich_color: Color of text to print \"\"\" upleft = \" \\u250f \" # Upper left corner upright = \" \\u2513 \" # Upper right corner downleft = \" \\u2517 \" # Lower left corner downright = \" \\u251B \" # Lower right corner vert = \" \\u2503 \" # Vertical line horz = \" \\u2501 \" # Horizontal line line = horz * ( len ( text ) + 2 ) rich . print ( f \"[ { rich_color } ] \\n\\t { upleft }{ line }{ upright } \" ) rich . print ( f \"[ { rich_color } ] \\t { vert } { text } { vert } \" ) rich . print ( f \"[ { rich_color } ] \\t { downleft }{ line }{ downright } \\n \" ) run_checks ( checks , report ) Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Parameters: Name Type Description Default checks List [ Union [ ShellCheck , GatorGraderCheck ]] The list of shell and GatorGrader checks to run. required Source code in gatorgrade/output/output.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def run_checks ( checks : List [ Union [ ShellCheck , GatorGraderCheck ]], report : Tuple [ str , str , str ] ) -> bool : \"\"\"Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Args: checks: The list of shell and GatorGrader checks to run. \"\"\" results = [] # run each of the checks for check in checks : result = None # run a shell check; this means # that it is going to run a command # in the shell as a part of a check if isinstance ( check , ShellCheck ): result = _run_shell_check ( check ) # run a check that GatorGrader implements elif isinstance ( check , GatorGraderCheck ): result = _run_gg_check ( check ) # there were results from running checks # and thus they must be displayed if result is not None : result . print () results . append ( result ) # determine if there are failures and then display them failed_results = list ( filter ( lambda result : not result . passed , results )) # only print failures list if there are failures to print if len ( failed_results ) > 0 : print ( \" \\n -~- FAILURES -~- \\n \" ) for result in failed_results : result . print ( show_diagnostic = True ) # determine how many of the checks passed and then # compute the total percentage of checks passed passed_count = len ( results ) - len ( failed_results ) # prevent division by zero if no results if len ( results ) == 0 : percent = 0 else : percent = round ( passed_count / len ( results ) * 100 ) # if the report is wanted, create output in line with their specifications if all ( report ): report_output_data = create_report_json ( passed_count , results , percent ) configure_report ( report , report_output_data ) # compute summary results and display them in the console summary = f \"Passed { passed_count } / { len ( results ) } ( { percent } %) of checks for { Path . cwd () . name } !\" summary_color = \"green\" if passed_count == len ( results ) else \"bright white\" print_with_border ( summary , summary_color ) # determine whether or not the run was a success or not: # if all of the tests pass then the function returns True; # otherwise the function must return False summary_status = True if passed_count == len ( results ) else False return summary_status write_json_or_md_file ( file_name , content_type , content ) Write a markdown or json file. Source code in gatorgrade/output/output.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def write_json_or_md_file ( file_name , content_type , content ): \"\"\"Write a markdown or json file.\"\"\" # try to store content in a file with user chosen format try : # Second argument has to be json or md with open ( file_name , \"w\" , encoding = \"utf-8\" ) as file : if content_type == \"json\" : json . dump ( content , file , indent = 4 ) else : file . write ( str ( content )) return True except Exception as e : raise ValueError ( \" \\n [red]Can't open or write the target file, check if you provide a valid path\" ) from e","title":"output"},{"location":"reference/output/output/#gatorgrade.output.output._run_gg_check","text":"Run a GatorGrader check. Parameters: Name Type Description Default check GatorGraderCheck The GatorGrader check to run. required Returns: Type Description CheckResult The result of running the GatorGrader check as a CheckResult. Source code in gatorgrade/output/output.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def _run_gg_check ( check : GatorGraderCheck ) -> CheckResult : \"\"\"Run a GatorGrader check. Args: check: The GatorGrader check to run. Returns: The result of running the GatorGrader check as a CheckResult. \"\"\" try : result = gator . grader ( check . gg_args ) passed = result [ 1 ] description = result [ 0 ] diagnostic = result [ 2 ] # If arguments are formatted incorrectly, catch the exception and # return it as the diagnostic message # Disable pylint to catch any type of exception thrown by GatorGrader except Exception as command_exception : # pylint: disable=W0703 passed = False description = f 'Invalid GatorGrader check: \" { \" \" . join ( check . gg_args ) } \"' diagnostic = f '\" { command_exception . __class__ } \" thrown by GatorGrader' return CheckResult ( passed = passed , description = description , json_info = check . json_info , diagnostic = diagnostic , )","title":"_run_gg_check()"},{"location":"reference/output/output/#gatorgrade.output.output._run_shell_check","text":"Run a shell check. Parameters: Name Type Description Default check ShellCheck The shell check to run. required Returns: Type Description CheckResult The result of running the shell check as a CheckResult. Source code in gatorgrade/output/output.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def _run_shell_check ( check : ShellCheck ) -> CheckResult : \"\"\"Run a shell check. Args: check: The shell check to run. Returns: The result of running the shell check as a CheckResult. \"\"\" result = subprocess . run ( check . command , shell = True , check = False , timeout = 300 , stdout = subprocess . PIPE , # Redirect STDERR to STDOUT so STDOUT and STDERR can be captured # together as diagnostic stderr = subprocess . STDOUT , ) passed = result . returncode == 0 # Add spaces after each newline to indent all lines of diagnostic diagnostic = ( \"\" if passed else result . stdout . decode () . strip () . replace ( \" \\n \" , \" \\n \" ) ) return CheckResult ( passed = passed , description = check . description , json_info = check . json_info , diagnostic = diagnostic , )","title":"_run_shell_check()"},{"location":"reference/output/output/#gatorgrade.output.output.configure_report","text":"Put together the contents of the report depending on the inputs of the user. Parameters: Name Type Description Default report_params Tuple [ str , str , str ] The details of what the user wants the report to look like report_params[0]: file or env report_params[1]: json or md report_params[2]: name of the file or env required report_output_data the json dictionary that will be used or converted to md required Source code in gatorgrade/output/output.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def configure_report ( report_params : Tuple [ str , str , str ], report_output_data_json : dict ): \"\"\"Put together the contents of the report depending on the inputs of the user. Args: report_params: The details of what the user wants the report to look like report_params[0]: file or env report_params[1]: json or md report_params[2]: name of the file or env report_output_data: the json dictionary that will be used or converted to md \"\"\" report_format = report_params [ 0 ] report_type = report_params [ 1 ] report_name = report_params [ 2 ] if report_type not in ( \"json\" , \"md\" ): raise ValueError ( \" \\n [red]The second argument of report has to be 'md' or 'json' \" ) # if the user wants markdown, get markdown content based on json if report_type == \"md\" : report_output_data_md = create_markdown_report_file ( report_output_data_json ) # if the user wants the data stored in a file: if report_format == \"file\" : if report_type == \"md\" : write_json_or_md_file ( report_name , report_type , report_output_data_md ) else : write_json_or_md_file ( report_name , report_type , report_output_data_json ) elif report_format == \"env\" : if report_name == \"GITHUB_STEP_SUMMARY\" : env_file = os . getenv ( \"GITHUB_STEP_SUMMARY\" ) if report_type == \"md\" : write_json_or_md_file ( env_file , report_type , report_output_data_md ) else : write_json_or_md_file ( env_file , report_type , report_output_data_json ) # Add json report into the GITHUB_ENV environment variable for data collection purpose env_file = os . getenv ( \"GITHUB_ENV\" ) with open ( env_file , \"a\" ) as myfile : myfile . write ( f \"JSON_REPORT= { report_output_data_json } \" ) # Add env else : raise ValueError ( \" \\n [red]The first argument of report has to be 'env' or 'file' \" )","title":"configure_report()"},{"location":"reference/output/output/#gatorgrade.output.output.create_markdown_report_file","text":"Create a markdown file using the created json to use in github actions summary, among other places. Parameters: Name Type Description Default json dict a dictionary containing the json that should be converted to markdown required Source code in gatorgrade/output/output.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def create_markdown_report_file ( json : dict ) -> str : \"\"\"Create a markdown file using the created json to use in github actions summary, among other places. Args: json: a dictionary containing the json that should be converted to markdown \"\"\" markdown_contents = \"\" passing_checks = [] failing_checks = [] num_checks = len ( json . get ( \"checks\" )) # write the total, amt correct and percentage score to md file markdown_contents += f \"# Gatorgrade Insights \\n\\n **Project Name:** { Path . cwd () . name } \\n **Amount Correct:** { ( json . get ( 'amount_correct' )) } / { num_checks } ( { ( json . get ( 'percentage_score' )) } %) \\n \" # split checks into passing and not passing for check in json . get ( \"checks\" ): # if the check is passing if check [ \"status\" ] == True : passing_checks . append ( check ) # if the check is failing else : failing_checks . append ( check ) # give short info about passing checks markdown_contents += \" \\n ## Passing Checks \\n \" for check in passing_checks : if \"description\" in check : markdown_contents += f \" \\n - [x] { check [ 'description' ] } \" else : markdown_contents += f \" \\n - [x] { check [ 'check' ] } \" # give extended information about failing checks markdown_contents += \" \\n\\n ## Failing Checks \\n \" # for each failing check, print out all related information for check in failing_checks : # for each key val pair in the check dictionary if \"description\" in check : markdown_contents += f \" \\n - [ ] { check [ 'description' ] } \" else : markdown_contents += f \" \\n - [ ] { check [ 'check' ] } \" if \"options\" in check : for i in check . get ( \"options\" ): if \"command\" == i : val = check [ \"options\" ][ \"command\" ] markdown_contents += f \" \\n\\t - **command** { val } \" if \"fragment\" == i : val = check [ \"options\" ][ \"fragment\" ] markdown_contents += f \" \\n\\t - **fragment:** { val } \" if \"tag\" == i : val = check [ \"options\" ][ \"tag\" ] markdown_contents += f \" \\n\\t - **tag:** { val } \" if \"count\" == i : val = check [ \"options\" ][ \"count\" ] markdown_contents += f \" \\n\\t - **count:** { val } \" if \"directory\" == i : val = check [ \"options\" ][ \"directory\" ] markdown_contents += f \" \\n\\t - **directory:** { val } \" if \"file\" == i : val = check [ \"options\" ][ \"file\" ] markdown_contents += f \" \\n\\t - **file:** { val } \" elif \"command\" in check : val = check [ \"command\" ] markdown_contents += f \" \\n\\t - **command:** { val } \" if \"diagnostic\" in check : markdown_contents += f \" \\n\\t - **diagnostic:** { check [ 'diagnostic' ] } \" markdown_contents += \" \\n \" return markdown_contents","title":"create_markdown_report_file()"},{"location":"reference/output/output/#gatorgrade.output.output.create_report_json","text":"Take checks and put them into json format in a dictionary. Parameters: Name Type Description Default passed_count the number of checks that passed required check_information the basic information about checks and their params required checkResults List [ CheckResult ] the list of check results that will be put in json required percent_passed the percentage of checks that passed required Source code in gatorgrade/output/output.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def create_report_json ( passed_count , checkResults : List [ CheckResult ], percent_passed , ) -> dict : \"\"\"Take checks and put them into json format in a dictionary. Args: passed_count: the number of checks that passed check_information: the basic information about checks and their params checkResults: the list of check results that will be put in json percent_passed: the percentage of checks that passed \"\"\" # create list to hold the key values for the dictionary that # will be converted into json overall_key_list = [ \"amount_correct\" , \"percentage_score\" , \"checks\" ] checks_list = [] overall_dict = {} # for each check: for i in range ( len ( checkResults )): # grab all of the information in it and add it to the checks list results_json = checkResults [ i ] . json_info results_json [ \"status\" ] = checkResults [ i ] . passed if not checkResults [ i ] . passed : results_json [ \"diagnostic\" ] = checkResults [ i ] . diagnostic checks_list . append ( results_json ) # create the dictionary for all of the check information overall_dict = dict ( zip ( overall_key_list , [ passed_count , percent_passed , checks_list ]) ) return overall_dict","title":"create_report_json()"},{"location":"reference/output/output/#gatorgrade.output.output.print_with_border","text":"Print text with a border. Parameters: Name Type Description Default text str Text to print required rich_color str Color of text to print required Source code in gatorgrade/output/output.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def print_with_border ( text : str , rich_color : str ): \"\"\"Print text with a border. Args: text: Text to print rich_color: Color of text to print \"\"\" upleft = \" \\u250f \" # Upper left corner upright = \" \\u2513 \" # Upper right corner downleft = \" \\u2517 \" # Lower left corner downright = \" \\u251B \" # Lower right corner vert = \" \\u2503 \" # Vertical line horz = \" \\u2501 \" # Horizontal line line = horz * ( len ( text ) + 2 ) rich . print ( f \"[ { rich_color } ] \\n\\t { upleft }{ line }{ upright } \" ) rich . print ( f \"[ { rich_color } ] \\t { vert } { text } { vert } \" ) rich . print ( f \"[ { rich_color } ] \\t { downleft }{ line }{ downright } \\n \" )","title":"print_with_border()"},{"location":"reference/output/output/#gatorgrade.output.output.run_checks","text":"Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Parameters: Name Type Description Default checks List [ Union [ ShellCheck , GatorGraderCheck ]] The list of shell and GatorGrader checks to run. required Source code in gatorgrade/output/output.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def run_checks ( checks : List [ Union [ ShellCheck , GatorGraderCheck ]], report : Tuple [ str , str , str ] ) -> bool : \"\"\"Run shell and GatorGrader checks and display whether each has passed or failed. Also, print a list of all failed checks with their diagnostics and a summary message that shows the overall fraction of passed checks. Args: checks: The list of shell and GatorGrader checks to run. \"\"\" results = [] # run each of the checks for check in checks : result = None # run a shell check; this means # that it is going to run a command # in the shell as a part of a check if isinstance ( check , ShellCheck ): result = _run_shell_check ( check ) # run a check that GatorGrader implements elif isinstance ( check , GatorGraderCheck ): result = _run_gg_check ( check ) # there were results from running checks # and thus they must be displayed if result is not None : result . print () results . append ( result ) # determine if there are failures and then display them failed_results = list ( filter ( lambda result : not result . passed , results )) # only print failures list if there are failures to print if len ( failed_results ) > 0 : print ( \" \\n -~- FAILURES -~- \\n \" ) for result in failed_results : result . print ( show_diagnostic = True ) # determine how many of the checks passed and then # compute the total percentage of checks passed passed_count = len ( results ) - len ( failed_results ) # prevent division by zero if no results if len ( results ) == 0 : percent = 0 else : percent = round ( passed_count / len ( results ) * 100 ) # if the report is wanted, create output in line with their specifications if all ( report ): report_output_data = create_report_json ( passed_count , results , percent ) configure_report ( report , report_output_data ) # compute summary results and display them in the console summary = f \"Passed { passed_count } / { len ( results ) } ( { percent } %) of checks for { Path . cwd () . name } !\" summary_color = \"green\" if passed_count == len ( results ) else \"bright white\" print_with_border ( summary , summary_color ) # determine whether or not the run was a success or not: # if all of the tests pass then the function returns True; # otherwise the function must return False summary_status = True if passed_count == len ( results ) else False return summary_status","title":"run_checks()"},{"location":"reference/output/output/#gatorgrade.output.output.write_json_or_md_file","text":"Write a markdown or json file. Source code in gatorgrade/output/output.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def write_json_or_md_file ( file_name , content_type , content ): \"\"\"Write a markdown or json file.\"\"\" # try to store content in a file with user chosen format try : # Second argument has to be json or md with open ( file_name , \"w\" , encoding = \"utf-8\" ) as file : if content_type == \"json\" : json . dump ( content , file , indent = 4 ) else : file . write ( str ( content )) return True except Exception as e : raise ValueError ( \" \\n [red]Can't open or write the target file, check if you provide a valid path\" ) from e","title":"write_json_or_md_file()"}]}